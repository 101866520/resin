{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\golde\\\\resin\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nvar _jsxFileName = \"C:\\\\Users\\\\golde\\\\resin\\\\src\\\\MultiBrush.js\";\n\n/**\r\n *  Copyright (c) 2016, The Regents of the University of California,\r\n *  through Lawrence Berkeley National Laboratory (subject to receipt\r\n *  of any required approvals from the U.S. Dept. of Energy).\r\n *  All rights reserved.\r\n *\r\n *  This source code is licensed under the BSD-style license found in the\r\n *  LICENSE file in the root directory of this source tree.\r\n */\nimport merge from \"merge\";\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { TimeRange } from \"pondjs\";\nimport getElementOffset from \"./utils/getElementOffset\";\n/**\r\n * Renders a brush with the range defined in the prop `timeRange`.\r\n */\n\nexport default class MultiBrush extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.hasNullBrush = () => {\n      return (this.props.timeRanges || []).length > 0 && this.props.timeRanges[this.props.timeRanges.length - 1] == null;\n    };\n\n    this.handleMouseClick = (e, brushIndex) => {\n      if (this.props.onTimeRangeClicked) {\n        this.props.onTimeRangeClicked(brushIndex);\n      }\n    };\n\n    this.state = {\n      isBrushing: false\n    };\n    this.handleBrushMouseDown = this.handleBrushMouseDown.bind(this);\n    this.handleOverlayMouseDown = this.handleOverlayMouseDown.bind(this);\n    this.handleHandleMouseDown = this.handleHandleMouseDown.bind(this);\n    this.handleMouseUp = this.handleMouseUp.bind(this);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n  }\n\n  viewport() {\n    const _this$props = this.props,\n          width = _this$props.width,\n          timeScale = _this$props.timeScale;\n    const viewBeginTime = timeScale.invert(0);\n    const viewEndTime = timeScale.invert(width);\n    return new TimeRange(viewBeginTime, viewEndTime);\n  } //\n  // Event handlers\n  //\n\n\n  handleBrushMouseDown(e, brush_idx) {\n    e.preventDefault();\n    const x = e.pageX,\n          y = e.pageY;\n    const xy0 = [Math.round(x), Math.round(y)];\n    const begin = +this.props.timeRanges[brush_idx].begin();\n    const end = +this.props.timeRanges[brush_idx].end();\n    document.addEventListener(\"mouseup\", this.handleMouseUp);\n    this.setState({\n      isBrushing: true,\n      brushingInitializationSite: \"brush\",\n      initialBrushBeginTime: begin,\n      initialBrushEndTime: end,\n      initialBrushXYPosition: xy0,\n      brushIndex: brush_idx\n    });\n  }\n\n  handleOverlayMouseDown(e) {\n    if (this.props.allowFreeDrawing || this.hasNullBrush()) {\n      e.preventDefault();\n      const offset = getElementOffset(this.overlay);\n      const x = e.pageX - offset.left;\n      const t = this.props.timeScale.invert(x).getTime();\n      document.addEventListener(\"mouseup\", this.handleMouseUp);\n      const drawingPosition = this.props.allowFreeDrawing ? this.props.timeRanges.length : this.props.timeRanges.length - 1;\n      this.setState({\n        isBrushing: true,\n        brushingInitializationSite: \"overlay\",\n        initialBrushBeginTime: t,\n        initialBrushEndTime: t,\n        initialBrushXYPosition: null,\n        brushIndex: drawingPosition\n      });\n    }\n  }\n\n  handleHandleMouseDown(e, handle, brushIndex) {\n    e.preventDefault();\n    const x = e.pageX,\n          y = e.pageY;\n    const xy0 = [Math.round(x), Math.round(y)];\n    const begin = this.props.timeRanges[brushIndex].begin().getTime();\n    const end = this.props.timeRanges[brushIndex].end().getTime();\n    document.addEventListener(\"mouseover\", this.handleMouseMove);\n    document.addEventListener(\"mouseup\", this.handleMouseUp);\n    this.setState({\n      isBrushing: true,\n      brushingInitializationSite: \"handle-\".concat(handle),\n      initialBrushBeginTime: begin,\n      initialBrushEndTime: end,\n      initialBrushXYPosition: xy0,\n      brushIndex: brushIndex\n    });\n  }\n\n  handleMouseUp(e) {\n    e.preventDefault();\n    document.removeEventListener(\"mouseover\", this.handleMouseMove);\n    document.removeEventListener(\"mouseup\", this.handleMouseUp);\n    const brushing_is = this.state.brushIndex;\n    this.setState({\n      isBrushing: false,\n      brushingInitializationSite: null,\n      initialBrushBeginTime: null,\n      initialBrushEndTime: null,\n      initialBrushXYPosition: null,\n      brushIndex: null\n    }, () => {\n      if (this.props.onUserMouseUp) {\n        this.props.onUserMouseUp(brushing_is);\n      }\n    });\n  }\n\n  handleMouseMove(e) {\n    e.preventDefault();\n    const x = e.pageX;\n    const y = e.pageY;\n    const xy = [Math.round(x), Math.round(y)];\n    const viewport = this.viewport();\n\n    if (this.state.isBrushing) {\n      let newBegin;\n      let newEnd;\n      const tb = this.state.initialBrushBeginTime;\n      const te = this.state.initialBrushEndTime;\n\n      if (this.state.brushingInitializationSite === \"overlay\") {\n        const offset = getElementOffset(this.overlay);\n        const xx = e.pageX - offset.left;\n        const t = this.props.timeScale.invert(xx).getTime();\n\n        if (t < tb) {\n          newBegin = t < viewport.begin().getTime() ? viewport.begin() : t;\n          newEnd = tb > viewport.end().getTime() ? viewport.end() : tb;\n        } else {\n          newBegin = tb < viewport.begin().getTime() ? viewport.begin() : tb;\n          newEnd = t > viewport.end().getTime() ? viewport.end() : t;\n        }\n      } else {\n        const xy0 = this.state.initialBrushXYPosition;\n        let timeOffset = this.props.timeScale.invert(xy0[0]).getTime() - this.props.timeScale.invert(xy[0]).getTime(); // Constrain\n\n        let startOffsetConstraint = timeOffset;\n        let endOffsetConstrain = timeOffset;\n\n        if (tb - timeOffset < viewport.begin()) {\n          startOffsetConstraint = tb - viewport.begin().getTime();\n        }\n\n        if (te - timeOffset > viewport.end()) {\n          endOffsetConstrain = te - viewport.end().getTime();\n        }\n\n        newBegin = this.state.brushingInitializationSite === \"brush\" || this.state.brushingInitializationSite === \"handle-left\" ? parseInt(tb - startOffsetConstraint, 10) : tb;\n        newEnd = this.state.brushingInitializationSite === \"brush\" || this.state.brushingInitializationSite === \"handle-right\" ? parseInt(te - endOffsetConstrain, 10) : te; // Swap if needed\n\n        if (newBegin > newEnd) {\n          var _ref = [newEnd, newBegin];\n          newBegin = _ref[0];\n          newEnd = _ref[1];\n        }\n      }\n\n      if (this.props.onTimeRangeChanged) {\n        this.props.onTimeRangeChanged(new TimeRange(newBegin, newEnd), this.state.brushIndex);\n      }\n    }\n  } //\n  // Render\n  //\n\n\n  renderOverlay() {\n    const _this$props2 = this.props,\n          width = _this$props2.width,\n          height = _this$props2.height;\n    let cursor;\n\n    switch (this.state.brushingInitializationSite) {\n      case \"handle-right\":\n      case \"handle-left\":\n        cursor = \"ew-resize\";\n        break;\n\n      case \"brush\":\n        cursor = \"move\";\n        break;\n\n      default:\n        cursor = this.props.allowFreeDrawing || this.hasNullBrush() ? \"crosshair\" : \"default\";\n    }\n\n    const overlayStyle = {\n      fill: \"white\",\n      opacity: 0,\n      cursor\n    };\n    return React.createElement(\"rect\", {\n      ref: c => {\n        this.overlay = c;\n      },\n      x: 0,\n      y: 0,\n      width: width,\n      height: height,\n      style: overlayStyle,\n      onClick: this.handleMouseClick,\n      onMouseDown: this.handleOverlayMouseDown,\n      onMouseUp: this.handleMouseUp,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 244\n      },\n      __self: this\n    });\n  }\n\n  renderBrush(timeRange, idx) {\n    const _this$props3 = this.props,\n          timeScale = _this$props3.timeScale,\n          height = _this$props3.height;\n\n    if (!timeRange) {\n      return React.createElement(\"g\", {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 264\n        },\n        __self: this\n      });\n    }\n\n    let cursor;\n\n    switch (this.state.brushingInitializationSite) {\n      case \"handle-right\":\n      case \"handle-left\":\n        cursor = \"ew-resize\";\n        break;\n\n      case \"overlay\":\n        cursor = this.props.allowFreeDrawing || this.hasNullBrush() ? \"crosshair\" : \"default\";\n        break;\n\n      default:\n        cursor = \"move\";\n    } // Style of the brush area\n\n\n    const brushDefaultStyle = {\n      fill: \"#777\",\n      fillOpacity: 0.3,\n      stroke: \"#fff\",\n      shapeRendering: \"crispEdges\",\n      cursor\n    };\n    const userStyle = this.props.style ? this.props.style(idx) : {};\n    const brushStyle = merge(true, brushDefaultStyle, userStyle);\n\n    if (!this.viewport().disjoint(timeRange)) {\n      const range = timeRange.intersection(this.viewport());\n      const begin = range.begin();\n      const end = range.end();\n      const _ref2 = [timeScale(begin), 0],\n            x = _ref2[0],\n            y = _ref2[1];\n      const endPos = timeScale(end);\n      let width = endPos - x;\n\n      if (width < 1) {\n        width = 1;\n      }\n\n      const bounds = {\n        x,\n        y,\n        width,\n        height\n      };\n      return React.createElement(\"rect\", Object.assign({}, bounds, {\n        key: \"\".concat(idx, \"-\").concat(brushStyle),\n        style: brushStyle,\n        pointerEvents: \"all\",\n        onClick: e => this.handleMouseClick(e, idx),\n        onMouseDown: e => this.handleBrushMouseDown(e, idx),\n        onMouseUp: this.handleMouseUp,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 308\n        },\n        __self: this\n      }));\n    }\n\n    return React.createElement(\"g\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 319\n      },\n      __self: this\n    });\n  }\n\n  renderHandles(timeRange, idx) {\n    const _this$props4 = this.props,\n          timeScale = _this$props4.timeScale,\n          height = _this$props4.height;\n\n    if (!timeRange) {\n      return React.createElement(\"g\", {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 326\n        },\n        __self: this\n      });\n    } // Style of the handles\n\n\n    const handleStyle = {\n      fill: \"white\",\n      opacity: 0,\n      cursor: \"ew-resize\"\n    };\n\n    if (!this.viewport().disjoint(timeRange)) {\n      const range = timeRange.intersection(this.viewport());\n\n      const _range$toJSON = range.toJSON(),\n            _range$toJSON2 = _slicedToArray(_range$toJSON, 2),\n            begin = _range$toJSON2[0],\n            end = _range$toJSON2[1];\n\n      const _ref3 = [timeScale(begin), 0],\n            x = _ref3[0],\n            y = _ref3[1];\n      const endPos = timeScale(end);\n      let width = endPos - x;\n\n      if (width < 1) {\n        width = 1;\n      }\n\n      const handleSize = this.props.handleSize;\n      const leftHandleBounds = {\n        x: x - 1,\n        y,\n        width: handleSize,\n        height\n      };\n      const rightHandleBounds = {\n        x: x + (width - handleSize),\n        y,\n        width: handleSize + 1,\n        height\n      };\n      return React.createElement(\"g\", {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 358\n        },\n        __self: this\n      }, React.createElement(\"rect\", Object.assign({}, leftHandleBounds, {\n        style: handleStyle,\n        pointerEvents: \"all\",\n        onMouseDown: e => this.handleHandleMouseDown(e, \"left\", idx),\n        onMouseUp: this.handleMouseUp,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 359\n        },\n        __self: this\n      })), React.createElement(\"rect\", Object.assign({}, rightHandleBounds, {\n        style: handleStyle,\n        pointerEvents: \"all\",\n        onMouseDown: e => this.handleHandleMouseDown(e, \"right\", idx),\n        onMouseUp: this.handleMouseUp,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 366\n        },\n        __self: this\n      })));\n    }\n\n    return React.createElement(\"g\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 376\n      },\n      __self: this\n    });\n  }\n\n  render() {\n    return React.createElement(\"g\", {\n      onMouseMove: this.handleMouseMove,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 381\n      },\n      __self: this\n    }, this.renderOverlay(), (this.props.timeRanges || []).map((timeRange, idx) => {\n      return React.createElement(\"g\", {\n        key: \"multibrush_\".concat(idx),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 385\n        },\n        __self: this\n      }, this.renderBrush(timeRange, idx), this.renderHandles(timeRange, idx));\n    }));\n  }\n\n}\nMultiBrush.propTypes = {\n  /**\r\n   * The timeranges for the brushes. Typically you would maintain this\r\n   * as state on the surrounding page, since it would likely control\r\n   * another page element, such as the range of the main chart. See\r\n   * also `onTimeRangeChanged()` for receiving notification of the\r\n   * brush range being changed by the user.\r\n   *\r\n   * Takes an array of Pond TimeRange object.\r\n   */\n  timeRanges: PropTypes.arrayOf(PropTypes.instanceOf(TimeRange)),\n\n  /**\r\n   * The brush is rendered as an SVG rect. You can specify the style\r\n   * of this rect using this prop. The brush style is a function that you\r\n   * provide. It will be called with the index of the TimeRange, corresponding\r\n   * to those in the `timeRanges` prop.\r\n   */\n  style: PropTypes.func,\n  //eslint-disable-line\n\n  /**\r\n   * The size of the invisible side handles. Defaults to 6 pixels.\r\n   */\n  handleSize: PropTypes.number,\n\n  /**\r\n   * If this prop is false, you will only be able to draw a new brush if the last position of the timeRanges\r\n   * array is equal to null, otherwise it will allow the free drawing and the index passed to onTimeRangeChanged\r\n   * will the equal to the length of the timeRanges array\r\n   */\n  allowFreeDrawing: PropTypes.bool,\n\n  /**\r\n   * A callback which will be called if the brush range is changed by\r\n   * the user. It is called with a Pond TimeRange object and the index position of\r\n   * the brush in the timeRanges prop.\r\n   */\n  onTimeRangeChanged: PropTypes.func,\n\n  /**\r\n   * when user stop drawing or dragging box\r\n   */\n  onUserMouseUp: PropTypes.func,\n\n  /**\r\n   * When the user clicks one of the TimeRanges\r\n   */\n  onTimeRangeClicked: PropTypes.func,\n\n  /**\r\n   * [Internal] The timeScale supplied by the surrounding ChartContainer\r\n   */\n  timeScale: PropTypes.func,\n\n  /**\r\n   * [Internal] The width supplied by the surrounding ChartContainer\r\n   */\n  width: PropTypes.number,\n\n  /**\r\n   * [Internal] The height supplied by the surrounding ChartContainer\r\n   */\n  height: PropTypes.number\n};\nMultiBrush.defaultProps = {\n  handleSize: 6,\n  allowFreeDrawing: true\n};","map":{"version":3,"sources":["C:\\Users\\golde\\resin\\src\\MultiBrush.js"],"names":["merge","React","PropTypes","TimeRange","getElementOffset","MultiBrush","Component","constructor","props","hasNullBrush","timeRanges","length","handleMouseClick","e","brushIndex","onTimeRangeClicked","state","isBrushing","handleBrushMouseDown","bind","handleOverlayMouseDown","handleHandleMouseDown","handleMouseUp","handleMouseMove","viewport","width","timeScale","viewBeginTime","invert","viewEndTime","brush_idx","preventDefault","x","pageX","y","pageY","xy0","Math","round","begin","end","document","addEventListener","setState","brushingInitializationSite","initialBrushBeginTime","initialBrushEndTime","initialBrushXYPosition","allowFreeDrawing","offset","overlay","left","t","getTime","drawingPosition","handle","removeEventListener","brushing_is","onUserMouseUp","xy","newBegin","newEnd","tb","te","xx","timeOffset","startOffsetConstraint","endOffsetConstrain","parseInt","onTimeRangeChanged","renderOverlay","height","cursor","overlayStyle","fill","opacity","c","renderBrush","timeRange","idx","brushDefaultStyle","fillOpacity","stroke","shapeRendering","userStyle","style","brushStyle","disjoint","range","intersection","endPos","bounds","renderHandles","handleStyle","toJSON","handleSize","leftHandleBounds","rightHandleBounds","render","map","propTypes","arrayOf","instanceOf","func","number","bool","defaultProps"],"mappings":"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","sourcesContent":["/**\r\n *  Copyright (c) 2016, The Regents of the University of California,\r\n *  through Lawrence Berkeley National Laboratory (subject to receipt\r\n *  of any required approvals from the U.S. Dept. of Energy).\r\n *  All rights reserved.\r\n *\r\n *  This source code is licensed under the BSD-style license found in the\r\n *  LICENSE file in the root directory of this source tree.\r\n */\r\n\r\nimport merge from \"merge\";\r\nimport React from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport { TimeRange } from \"pondjs\";\r\nimport getElementOffset from \"./utils/getElementOffset\";\r\n\r\n/**\r\n * Renders a brush with the range defined in the prop `timeRange`.\r\n */\r\nexport default class MultiBrush extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      isBrushing: false\r\n    };\r\n\r\n    this.handleBrushMouseDown = this.handleBrushMouseDown.bind(this);\r\n    this.handleOverlayMouseDown = this.handleOverlayMouseDown.bind(this);\r\n    this.handleHandleMouseDown = this.handleHandleMouseDown.bind(this);\r\n    this.handleMouseUp = this.handleMouseUp.bind(this);\r\n    this.handleMouseMove = this.handleMouseMove.bind(this);\r\n  }\r\n\r\n  viewport() {\r\n    const { width, timeScale } = this.props;\r\n    const viewBeginTime = timeScale.invert(0);\r\n    const viewEndTime = timeScale.invert(width);\r\n    return new TimeRange(viewBeginTime, viewEndTime);\r\n  }\r\n\r\n  //\r\n  // Event handlers\r\n  //\r\n\r\n  handleBrushMouseDown(e, brush_idx) {\r\n    e.preventDefault();\r\n\r\n    const { pageX: x, pageY: y } = e;\r\n    const xy0 = [Math.round(x), Math.round(y)];\r\n    const begin = +this.props.timeRanges[brush_idx].begin();\r\n    const end = +this.props.timeRanges[brush_idx].end();\r\n\r\n    document.addEventListener(\"mouseup\", this.handleMouseUp);\r\n\r\n    this.setState({\r\n      isBrushing: true,\r\n      brushingInitializationSite: \"brush\",\r\n      initialBrushBeginTime: begin,\r\n      initialBrushEndTime: end,\r\n      initialBrushXYPosition: xy0,\r\n      brushIndex: brush_idx\r\n    });\r\n  }\r\n\r\n  handleOverlayMouseDown(e) {\r\n    if (this.props.allowFreeDrawing || this.hasNullBrush()) {\r\n      e.preventDefault();\r\n\r\n      const offset = getElementOffset(this.overlay);\r\n      const x = e.pageX - offset.left;\r\n      const t = this.props.timeScale.invert(x).getTime();\r\n\r\n      document.addEventListener(\"mouseup\", this.handleMouseUp);\r\n\r\n      const drawingPosition = this.props.allowFreeDrawing\r\n        ? this.props.timeRanges.length\r\n        : this.props.timeRanges.length - 1;\r\n\r\n      this.setState({\r\n        isBrushing: true,\r\n        brushingInitializationSite: \"overlay\",\r\n        initialBrushBeginTime: t,\r\n        initialBrushEndTime: t,\r\n        initialBrushXYPosition: null,\r\n        brushIndex: drawingPosition\r\n      });\r\n    }\r\n  }\r\n\r\n  hasNullBrush = () => {\r\n    return (\r\n      (this.props.timeRanges || []).length > 0 &&\r\n      this.props.timeRanges[this.props.timeRanges.length - 1] == null\r\n    );\r\n  };\r\n\r\n  handleMouseClick = (e, brushIndex) => {\r\n    if (this.props.onTimeRangeClicked) {\r\n      this.props.onTimeRangeClicked(brushIndex);\r\n    }\r\n  };\r\n\r\n  handleHandleMouseDown(e, handle, brushIndex) {\r\n    e.preventDefault();\r\n\r\n    const { pageX: x, pageY: y } = e;\r\n    const xy0 = [Math.round(x), Math.round(y)];\r\n    const begin = this.props.timeRanges[brushIndex].begin().getTime();\r\n    const end = this.props.timeRanges[brushIndex].end().getTime();\r\n\r\n    document.addEventListener(\"mouseover\", this.handleMouseMove);\r\n    document.addEventListener(\"mouseup\", this.handleMouseUp);\r\n\r\n    this.setState({\r\n      isBrushing: true,\r\n      brushingInitializationSite: `handle-${handle}`,\r\n      initialBrushBeginTime: begin,\r\n      initialBrushEndTime: end,\r\n      initialBrushXYPosition: xy0,\r\n      brushIndex: brushIndex\r\n    });\r\n  }\r\n\r\n  handleMouseUp(e) {\r\n    e.preventDefault();\r\n\r\n    document.removeEventListener(\"mouseover\", this.handleMouseMove);\r\n    document.removeEventListener(\"mouseup\", this.handleMouseUp);\r\n\r\n    const brushing_is = this.state.brushIndex;\r\n    this.setState(\r\n      {\r\n        isBrushing: false,\r\n        brushingInitializationSite: null,\r\n        initialBrushBeginTime: null,\r\n        initialBrushEndTime: null,\r\n        initialBrushXYPosition: null,\r\n        brushIndex: null\r\n      },\r\n      () => {\r\n        if (this.props.onUserMouseUp) {\r\n          this.props.onUserMouseUp(brushing_is);\r\n        }\r\n      }\r\n    );\r\n  }\r\n\r\n  handleMouseMove(e) {\r\n    e.preventDefault();\r\n\r\n    const x = e.pageX;\r\n    const y = e.pageY;\r\n    const xy = [Math.round(x), Math.round(y)];\r\n    const viewport = this.viewport();\r\n\r\n    if (this.state.isBrushing) {\r\n      let newBegin;\r\n      let newEnd;\r\n\r\n      const tb = this.state.initialBrushBeginTime;\r\n      const te = this.state.initialBrushEndTime;\r\n\r\n      if (this.state.brushingInitializationSite === \"overlay\") {\r\n        const offset = getElementOffset(this.overlay);\r\n        const xx = e.pageX - offset.left;\r\n        const t = this.props.timeScale.invert(xx).getTime();\r\n        if (t < tb) {\r\n          newBegin = t < viewport.begin().getTime() ? viewport.begin() : t;\r\n          newEnd = tb > viewport.end().getTime() ? viewport.end() : tb;\r\n        } else {\r\n          newBegin = tb < viewport.begin().getTime() ? viewport.begin() : tb;\r\n          newEnd = t > viewport.end().getTime() ? viewport.end() : t;\r\n        }\r\n      } else {\r\n        const xy0 = this.state.initialBrushXYPosition;\r\n        let timeOffset =\r\n          this.props.timeScale.invert(xy0[0]).getTime() -\r\n          this.props.timeScale.invert(xy[0]).getTime();\r\n\r\n        // Constrain\r\n        let startOffsetConstraint = timeOffset;\r\n        let endOffsetConstrain = timeOffset;\r\n        if (tb - timeOffset < viewport.begin()) {\r\n          startOffsetConstraint = tb - viewport.begin().getTime();\r\n        }\r\n        if (te - timeOffset > viewport.end()) {\r\n          endOffsetConstrain = te - viewport.end().getTime();\r\n        }\r\n\r\n        newBegin =\r\n          this.state.brushingInitializationSite === \"brush\" ||\r\n          this.state.brushingInitializationSite === \"handle-left\"\r\n            ? parseInt(tb - startOffsetConstraint, 10)\r\n            : tb;\r\n        newEnd =\r\n          this.state.brushingInitializationSite === \"brush\" ||\r\n          this.state.brushingInitializationSite === \"handle-right\"\r\n            ? parseInt(te - endOffsetConstrain, 10)\r\n            : te;\r\n\r\n        // Swap if needed\r\n        if (newBegin > newEnd) [newBegin, newEnd] = [newEnd, newBegin];\r\n      }\r\n\r\n      if (this.props.onTimeRangeChanged) {\r\n        this.props.onTimeRangeChanged(\r\n          new TimeRange(newBegin, newEnd),\r\n          this.state.brushIndex\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  //\r\n  // Render\r\n  //\r\n\r\n  renderOverlay() {\r\n    const { width, height } = this.props;\r\n\r\n    let cursor;\r\n    switch (this.state.brushingInitializationSite) {\r\n      case \"handle-right\":\r\n      case \"handle-left\":\r\n        cursor = \"ew-resize\";\r\n        break;\r\n      case \"brush\":\r\n        cursor = \"move\";\r\n        break;\r\n      default:\r\n        cursor =\r\n          this.props.allowFreeDrawing || this.hasNullBrush()\r\n            ? \"crosshair\"\r\n            : \"default\";\r\n    }\r\n\r\n    const overlayStyle = {\r\n      fill: \"white\",\r\n      opacity: 0,\r\n      cursor\r\n    };\r\n    return (\r\n      <rect\r\n        ref={c => {\r\n          this.overlay = c;\r\n        }}\r\n        x={0}\r\n        y={0}\r\n        width={width}\r\n        height={height}\r\n        style={overlayStyle}\r\n        onClick={this.handleMouseClick}\r\n        onMouseDown={this.handleOverlayMouseDown}\r\n        onMouseUp={this.handleMouseUp}\r\n      />\r\n    );\r\n  }\r\n\r\n  renderBrush(timeRange, idx) {\r\n    const { timeScale, height } = this.props;\r\n\r\n    if (!timeRange) {\r\n      return <g />;\r\n    }\r\n\r\n    let cursor;\r\n    switch (this.state.brushingInitializationSite) {\r\n      case \"handle-right\":\r\n      case \"handle-left\":\r\n        cursor = \"ew-resize\";\r\n        break;\r\n      case \"overlay\":\r\n        cursor =\r\n          this.props.allowFreeDrawing || this.hasNullBrush()\r\n            ? \"crosshair\"\r\n            : \"default\";\r\n        break;\r\n      default:\r\n        cursor = \"move\";\r\n    }\r\n\r\n    // Style of the brush area\r\n    const brushDefaultStyle = {\r\n      fill: \"#777\",\r\n      fillOpacity: 0.3,\r\n      stroke: \"#fff\",\r\n      shapeRendering: \"crispEdges\",\r\n      cursor\r\n    };\r\n    const userStyle = this.props.style ? this.props.style(idx) : {};\r\n    const brushStyle = merge(true, brushDefaultStyle, userStyle);\r\n\r\n    if (!this.viewport().disjoint(timeRange)) {\r\n      const range = timeRange.intersection(this.viewport());\r\n      const begin = range.begin();\r\n      const end = range.end();\r\n      const [x, y] = [timeScale(begin), 0];\r\n      const endPos = timeScale(end);\r\n      let width = endPos - x;\r\n      if (width < 1) {\r\n        width = 1;\r\n      }\r\n\r\n      const bounds = { x, y, width, height };\r\n\r\n      return (\r\n        <rect\r\n          {...bounds}\r\n          key={`${idx}-${brushStyle}`}\r\n          style={brushStyle}\r\n          pointerEvents=\"all\"\r\n          onClick={e => this.handleMouseClick(e, idx)}\r\n          onMouseDown={e => this.handleBrushMouseDown(e, idx)}\r\n          onMouseUp={this.handleMouseUp}\r\n        />\r\n      );\r\n    }\r\n    return <g />;\r\n  }\r\n\r\n  renderHandles(timeRange, idx) {\r\n    const { timeScale, height } = this.props;\r\n\r\n    if (!timeRange) {\r\n      return <g />;\r\n    }\r\n\r\n    // Style of the handles\r\n    const handleStyle = {\r\n      fill: \"white\",\r\n      opacity: 0,\r\n      cursor: \"ew-resize\"\r\n    };\r\n\r\n    if (!this.viewport().disjoint(timeRange)) {\r\n      const range = timeRange.intersection(this.viewport());\r\n      const [begin, end] = range.toJSON();\r\n      const [x, y] = [timeScale(begin), 0];\r\n      const endPos = timeScale(end);\r\n\r\n      let width = endPos - x;\r\n      if (width < 1) {\r\n        width = 1;\r\n      }\r\n\r\n      const handleSize = this.props.handleSize;\r\n\r\n      const leftHandleBounds = { x: x - 1, y, width: handleSize, height };\r\n      const rightHandleBounds = {\r\n        x: x + (width - handleSize),\r\n        y,\r\n        width: handleSize + 1,\r\n        height\r\n      };\r\n\r\n      return (\r\n        <g>\r\n          <rect\r\n            {...leftHandleBounds}\r\n            style={handleStyle}\r\n            pointerEvents=\"all\"\r\n            onMouseDown={e => this.handleHandleMouseDown(e, \"left\", idx)}\r\n            onMouseUp={this.handleMouseUp}\r\n          />\r\n          <rect\r\n            {...rightHandleBounds}\r\n            style={handleStyle}\r\n            pointerEvents=\"all\"\r\n            onMouseDown={e => this.handleHandleMouseDown(e, \"right\", idx)}\r\n            onMouseUp={this.handleMouseUp}\r\n          />\r\n        </g>\r\n      );\r\n    }\r\n    return <g />;\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <g onMouseMove={this.handleMouseMove}>\r\n        {this.renderOverlay()}\r\n        {(this.props.timeRanges || []).map((timeRange, idx) => {\r\n          return (\r\n            <g key={`multibrush_${idx}`}>\r\n              {this.renderBrush(timeRange, idx)}\r\n              {this.renderHandles(timeRange, idx)}\r\n            </g>\r\n          );\r\n        })}\r\n      </g>\r\n    );\r\n  }\r\n}\r\n\r\nMultiBrush.propTypes = {\r\n  /**\r\n   * The timeranges for the brushes. Typically you would maintain this\r\n   * as state on the surrounding page, since it would likely control\r\n   * another page element, such as the range of the main chart. See\r\n   * also `onTimeRangeChanged()` for receiving notification of the\r\n   * brush range being changed by the user.\r\n   *\r\n   * Takes an array of Pond TimeRange object.\r\n   */\r\n  timeRanges: PropTypes.arrayOf(PropTypes.instanceOf(TimeRange)),\r\n\r\n  /**\r\n   * The brush is rendered as an SVG rect. You can specify the style\r\n   * of this rect using this prop. The brush style is a function that you\r\n   * provide. It will be called with the index of the TimeRange, corresponding\r\n   * to those in the `timeRanges` prop.\r\n   */\r\n  style: PropTypes.func, //eslint-disable-line\r\n\r\n  /**\r\n   * The size of the invisible side handles. Defaults to 6 pixels.\r\n   */\r\n  handleSize: PropTypes.number,\r\n\r\n  /**\r\n   * If this prop is false, you will only be able to draw a new brush if the last position of the timeRanges\r\n   * array is equal to null, otherwise it will allow the free drawing and the index passed to onTimeRangeChanged\r\n   * will the equal to the length of the timeRanges array\r\n   */\r\n  allowFreeDrawing: PropTypes.bool,\r\n\r\n  /**\r\n   * A callback which will be called if the brush range is changed by\r\n   * the user. It is called with a Pond TimeRange object and the index position of\r\n   * the brush in the timeRanges prop.\r\n   */\r\n  onTimeRangeChanged: PropTypes.func,\r\n\r\n  /**\r\n   * when user stop drawing or dragging box\r\n   */\r\n  onUserMouseUp: PropTypes.func,\r\n\r\n  /**\r\n   * When the user clicks one of the TimeRanges\r\n   */\r\n  onTimeRangeClicked: PropTypes.func,\r\n\r\n  /**\r\n   * [Internal] The timeScale supplied by the surrounding ChartContainer\r\n   */\r\n  timeScale: PropTypes.func,\r\n\r\n  /**\r\n   * [Internal] The width supplied by the surrounding ChartContainer\r\n   */\r\n  width: PropTypes.number,\r\n\r\n  /**\r\n   * [Internal] The height supplied by the surrounding ChartContainer\r\n   */\r\n  height: PropTypes.number\r\n};\r\n\r\nMultiBrush.defaultProps = {\r\n  handleSize: 6,\r\n  allowFreeDrawing: true\r\n};\r\n"]},"metadata":{},"sourceType":"module"}