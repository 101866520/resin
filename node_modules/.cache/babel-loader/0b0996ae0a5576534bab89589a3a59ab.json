{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\golde\\\\resin\\\\src\\\\ChartRow.js\";\n\n/**\r\n *  Copyright (c) 2015-present, The Regents of the University of California,\r\n *  through Lawrence Berkeley National Laboratory (subject to receipt\r\n *  of any required approvals from the U.S. Dept. of Energy).\r\n *  All rights reserved.\r\n *\r\n *  This source code is licensed under the BSD-style license found in the\r\n *  LICENSE file in the root directory of this source tree.\r\n */\nimport _ from \"underscore\";\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { easeSinOut } from \"d3-ease\";\nimport { scaleLinear, scaleLog, scalePow } from \"d3-scale\";\nimport { areComponentsEqual } from \"react-hot-loader\";\nimport Brush from \"./Brush\";\nimport YAxis from \"./YAxis\";\nimport Charts from \"./Charts\";\nimport MultiBrush from \"./MultiBrush\";\nimport TimeMarker from \"./TimeMarker\";\nimport ScaleInterpolator from \"./utils/interpolators\";\n\nfunction createScale(yaxis, type, min, max, y0, y1) {\n  let scale;\n\n  if (_.isUndefined(min) || _.isUndefined(max)) {\n    scale = null;\n  } else if (type === \"linear\") {\n    scale = scaleLinear().domain([min, max]).range([y0, y1]).nice();\n  } else if (type === \"log\") {\n    const base = yaxis.props.logBase || 10;\n    scale = scaleLog().base(base).domain([min, max]).range([y0, y1]);\n  } else if (type === \"power\") {\n    const power = yaxis.props.powerExponent || 2;\n    scale = scalePow().exponent(power).domain([min, max]).range([y0, y1]);\n  }\n\n  return scale;\n}\n/**\r\n * A ChartRow is a container for a set of YAxis and multiple charts\r\n * which are overlaid on each other in a central canvas.\r\n *\r\n * Here is an example where a single `<ChartRow>` is defined within\r\n * the `<ChartContainer>`. Of course you can have any number of rows.\r\n *\r\n * For this row we specify the one prop `height` as 200 pixels high.\r\n *\r\n * Within the `<ChartRow>` we add:\r\n *\r\n * * `<YAxis>` elements for axes to the left of the chart\r\n * * `<Chart>` block containing our central chart area\r\n * * `<YAxis>` elements for our axes to the right of the charts\r\n *\r\n * ```\r\n * <ChartContainer timeRange={audSeries.timerange()}>\r\n *     <ChartRow height=\"200\">\r\n *         <YAxis />\r\n *         <YAxis />\r\n *         <Charts>\r\n *             charts...\r\n *        </Charts>\r\n *         <YAxis />\r\n *     </ChartRow>\r\n * </ChartContainer>\r\n * ```\r\n */\n\n\nexport default class ChartRow extends React.Component {\n  constructor(props) {\n    super(props); // id of clipping rectangle we will generate and use for each child\n    // chart. Lives in state to ensure just one clipping rectangle and\n    // id per chart row instance; we don't want a fresh id generated on\n    // each render.\n\n    this.isChildYAxis = child => areComponentsEqual(child.type, YAxis) || _.has(child.props, \"min\") && _.has(child.props, \"max\");\n\n    const clipId = _.uniqueId(\"clip_\");\n\n    const clipPathURL = \"url(#\".concat(clipId, \")\");\n    this.state = {\n      clipId,\n      clipPathURL\n    };\n    this.mounted = true;\n  }\n\n  updateScales(props) {\n    const axisMargin = props.axisMargin;\n    const innerHeight = +props.height - axisMargin * 2;\n    const rangeTop = axisMargin;\n    const rangeBottom = innerHeight - axisMargin;\n    React.Children.forEach(props.children, child => {\n      if (child === null) return;\n\n      if (this.isChildYAxis(child)) {\n        const _child$props = child.props,\n              id = _child$props.id,\n              max = _child$props.max,\n              min = _child$props.min,\n              _child$props$transiti = _child$props.transition,\n              transition = _child$props$transiti === void 0 ? 0 : _child$props$transiti,\n              _child$props$type = _child$props.type,\n              type = _child$props$type === void 0 ? \"linear\" : _child$props$type;\n\n        if (!_.has(this.scaleMap, id)) {\n          // If necessary, initialize a ScaleInterpolator for this y-axis.\n          // When the yScale changes, we will update this interpolator.\n          this.scaleMap[id] = new ScaleInterpolator(transition, easeSinOut, s => {\n            const yAxisScalerMap = this.state.yAxisScalerMap;\n            yAxisScalerMap[id] = s;\n            if (this.mounted) this.setState(yAxisScalerMap);\n          });\n        } // Get the vertical scale for this y-axis.\n\n\n        let scale;\n\n        if (_.has(child.props, \"yScale\")) {\n          // If the yScale prop is passed explicitly, use that.\n          scale = child.props.yScale;\n        } else {\n          // Otherwise, compute the scale based on the max and min props.\n          scale = createScale(child, type, min, max, rangeBottom, rangeTop);\n        } // Update the scale on the interpolator for this y-axis.\n\n\n        const cacheKey = \"\".concat(type, \"-\").concat(min, \"-\").concat(max, \"-\").concat(rangeBottom, \"-\").concat(rangeTop);\n        this.scaleMap[id].setScale(cacheKey, scale);\n      }\n    }); // Update the state with the newly interpolated scaler for each y-axis.\n\n    const scalerMap = {};\n\n    _.forEach(this.scaleMap, (interpolator, id) => {\n      scalerMap[id] = interpolator.scaler();\n    });\n\n    if (this.mounted) this.setState({\n      yAxisScalerMap: scalerMap\n    });\n  }\n\n  componentWillMount() {\n    // Our chart scales are driven off a mapping between id of the axis\n    // and the scale that axis represents. Depending on the transition time,\n    // this scale will animate over time. The controller of this animation is\n    // the ScaleInterpolator. We create new Scale Interpolators here for each\n    // axis id.\n    this.scaleMap = {};\n    this.updateScales(this.props);\n  }\n  /**\r\n   * When we get changes to the row's props we update our map of\r\n   * axis scales.\r\n   */\n\n\n  componentWillReceiveProps(nextProps) {\n    this.updateScales(nextProps);\n  }\n\n  componentWillUnmount() {\n    this.mounted = false;\n  }\n\n  render() {\n    const _this$props = this.props,\n          paddingLeft = _this$props.paddingLeft,\n          paddingRight = _this$props.paddingRight;\n    const axes = []; // Contains all the yAxis elements used in the render\n\n    const chartList = []; // Contains all the Chart elements used in the render\n    // Dimensions\n\n    const innerHeight = +this.props.height - this.props.axisMargin * 2; //\n    // Build a map of elements that occupy left or right slots next to the\n    // chart.\n    //\n    // If an element has both and id and a min/max range, then we consider\n    // it to be a y axis. For those we calculate a d3 scale that can be\n    // reference by a chart. That scale will also be available to the axis\n    // when it renders.\n    //\n    // For this row, we will need to know how many axis slots we are using.\n    //\n\n    const yAxisMap = {}; // Maps axis id -> axis element\n\n    const leftAxisList = []; // Ordered list of left axes ids\n\n    const rightAxisList = []; // Ordered list of right axes ids\n\n    let alignLeft = true;\n    React.Children.forEach(this.props.children, child => {\n      if (child === null) return;\n\n      if (areComponentsEqual(child.type, Charts)) {\n        alignLeft = false;\n      } else {\n        const id = child.props.id; // Check to see if we think this 'axis' is actually an axis\n\n        if (this.isChildYAxis(child)) {\n          const yaxis = child;\n\n          if (yaxis.props.id && yaxis.props.visible !== false) {\n            // Relate id to the axis\n            yAxisMap[yaxis.props.id] = yaxis;\n          } // Columns counts\n\n\n          if (alignLeft) {\n            leftAxisList.push(id);\n          } else {\n            rightAxisList.push(id);\n          }\n        }\n      }\n    }); // Since we'll be building the left axis items from the inside to the outside\n\n    leftAxisList.reverse(); //\n    // Push each axis onto the axes, transforming each into its\n    // column location\n    //\n\n    let transform;\n    let id;\n    let props;\n    let axis;\n    let posx = 0; // Space used by columns on left and right of charts\n\n    const leftWidth = _.reduce(this.props.leftAxisWidths, (a, b) => a + b, 0);\n\n    const rightWidth = _.reduce(this.props.rightAxisWidths, (a, b) => a + b, 0);\n\n    const chartWidth = this.props.width - leftWidth - rightWidth - paddingLeft - paddingRight;\n    posx = leftWidth;\n\n    for (let leftColumnIndex = 0; leftColumnIndex < this.props.leftAxisWidths.length; leftColumnIndex += 1) {\n      const colWidth = this.props.leftAxisWidths[leftColumnIndex];\n      posx -= colWidth;\n\n      if (colWidth > 0 && leftColumnIndex < leftAxisList.length) {\n        id = leftAxisList[leftColumnIndex];\n\n        if (_.has(yAxisMap, id)) {\n          transform = \"translate(\".concat(posx + paddingLeft, \",0)\"); // Additional props for left aligned axes\n\n          props = {\n            width: colWidth,\n            height: innerHeight,\n            chartExtent: chartWidth,\n            isInnerAxis: leftColumnIndex === 0,\n            align: \"left\",\n            scale: this.scaleMap[id].latestScale()\n          }; // Cloned left axis\n\n          axis = React.cloneElement(yAxisMap[id], props);\n          axes.push(React.createElement(\"g\", {\n            key: \"y-axis-left-\".concat(leftColumnIndex),\n            transform: transform,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 262\n            },\n            __self: this\n          }, axis));\n        }\n      }\n    }\n\n    posx = this.props.width - rightWidth - paddingRight;\n\n    for (let rightColumnIndex = 0; rightColumnIndex < this.props.rightAxisWidths.length; rightColumnIndex += 1) {\n      const colWidth = this.props.rightAxisWidths[rightColumnIndex];\n\n      if (colWidth > 0 && rightColumnIndex < rightAxisList.length) {\n        id = rightAxisList[rightColumnIndex];\n\n        if (_.has(yAxisMap, id)) {\n          transform = \"translate(\".concat(posx + paddingLeft, \",0)\"); // Additional props for right aligned axes\n\n          props = {\n            width: colWidth,\n            height: innerHeight,\n            chartExtent: chartWidth,\n            //showGrid: this.props.showGrid,\n            isInnerAxis: rightColumnIndex === 0,\n            align: \"right\",\n            scale: this.scaleMap[id].latestScale()\n          }; // Cloned right axis\n\n          axis = React.cloneElement(yAxisMap[id], props);\n          axes.push(React.createElement(\"g\", {\n            key: \"y-axis-right-\".concat(rightColumnIndex),\n            transform: transform,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 297\n            },\n            __self: this\n          }, axis));\n        }\n      }\n\n      posx += colWidth;\n    } //\n    // Push each chart onto the chartList, transforming each to the right\n    // of the left axis slots and specifying its width. Each chart is passed\n    // its time and y-scale. The y-scale is looked up in scaleMap, whose\n    // current value is stored in the component state.\n    //\n\n\n    const chartTransform = \"translate(\".concat(leftWidth + paddingLeft, \",0)\");\n    let keyCount = 0;\n    React.Children.forEach(this.props.children, child => {\n      if (child === null) return;\n\n      if (areComponentsEqual(child.type, Charts)) {\n        const charts = child;\n        React.Children.forEach(charts.props.children, chart => {\n          if (!_.has(chart.props, \"visible\") || chart.props.visible) {\n            let scale = null;\n\n            if (_.has(this.state.yAxisScalerMap, chart.props.axis)) {\n              scale = this.state.yAxisScalerMap[chart.props.axis];\n            }\n\n            let ytransition = null;\n\n            if (_.has(this.scaleMap, chart.props.axis)) {\n              ytransition = this.scaleMap[chart.props.axis];\n            }\n\n            const chartProps = {\n              key: keyCount,\n              width: chartWidth,\n              height: innerHeight,\n              timeScale: this.props.timeScale,\n              timeFormat: this.props.timeFormat\n            };\n\n            if (scale) {\n              chartProps.yScale = scale;\n            }\n\n            if (ytransition) {\n              chartProps.transition = ytransition;\n            }\n\n            chartList.push(React.cloneElement(chart, chartProps));\n            keyCount += 1;\n          }\n        });\n      }\n    }); //\n    // Push each child Brush on to the brush list.  We need brushed to be\n    // rendered last (on top) of everything else in the Z order, both for\n    // visual correctness and to ensure that the brush gets mouse events\n    // before anything underneath\n    //\n\n    const brushList = [];\n    const multiBrushList = [];\n    keyCount = 0;\n    React.Children.forEach(this.props.children, child => {\n      if (child === null) return;\n\n      if (areComponentsEqual(child.type, Brush) || areComponentsEqual(child.type, MultiBrush)) {\n        const brushProps = {\n          key: \"brush-\".concat(keyCount),\n          width: chartWidth,\n          height: innerHeight,\n          timeScale: this.props.timeScale\n        };\n\n        if (areComponentsEqual(child.type, Brush)) {\n          brushList.push(React.cloneElement(child, brushProps));\n        } else {\n          multiBrushList.push(React.cloneElement(child, brushProps));\n        }\n      }\n\n      keyCount += 1;\n    });\n    const charts = React.createElement(\"g\", {\n      transform: chartTransform,\n      key: \"event-rect-group\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 388\n      },\n      __self: this\n    }, React.createElement(\"g\", {\n      key: \"charts\",\n      clipPath: this.state.clipPathURL,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 389\n      },\n      __self: this\n    }, chartList)); //\n    // Clipping\n    //\n\n    const clipper = React.createElement(\"defs\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 399\n      },\n      __self: this\n    }, React.createElement(\"clipPath\", {\n      id: this.state.clipId,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 400\n      },\n      __self: this\n    }, React.createElement(\"rect\", {\n      x: \"0\",\n      y: \"0\",\n      style: {\n        strokeOpacity: 0.0\n      },\n      width: chartWidth,\n      height: innerHeight,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 401\n      },\n      __self: this\n    }))); //\n    // Brush\n    //\n\n    const brushes = React.createElement(\"g\", {\n      transform: chartTransform,\n      key: \"brush-group\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 416\n      },\n      __self: this\n    }, brushList); //\n    // Multi Brush\n    //\n\n    const multiBrushes = React.createElement(\"g\", {\n      transform: chartTransform,\n      key: \"multi-brush-group\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 425\n      },\n      __self: this\n    }, multiBrushList); //\n    // TimeMarker used as a tracker\n    //\n\n    let tracker;\n\n    if (this.props.trackerTime) {\n      const timeFormat = this.props.trackerTimeFormat || this.props.timeFormat;\n      const timeMarkerProps = {\n        timeFormat,\n        showLine: false,\n        showTime: this.props.trackerShowTime,\n        time: this.props.trackerTime,\n        timeScale: this.props.timeScale,\n        width: chartWidth,\n        infoStyle: this.props.trackerStyle\n      };\n\n      if (this.props.trackerInfoValues) {\n        timeMarkerProps.infoWidth = this.props.trackerInfoWidth;\n        timeMarkerProps.infoHeight = this.props.trackerInfoHeight;\n        timeMarkerProps.infoValues = this.props.trackerInfoValues;\n        timeMarkerProps.timeFormat = this.props.trackerTimeFormat;\n      }\n\n      const trackerStyle = {\n        pointerEvents: \"none\"\n      };\n      const trackerTransform = \"translate(\".concat(leftWidth + paddingLeft, \",0)\");\n      tracker = React.createElement(\"g\", {\n        key: \"tracker-group\",\n        style: trackerStyle,\n        transform: trackerTransform,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 457\n        },\n        __self: this\n      }, React.createElement(TimeMarker, Object.assign({}, timeMarkerProps, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 462\n        },\n        __self: this\n      })));\n    }\n\n    return React.createElement(\"g\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 468\n      },\n      __self: this\n    }, clipper, axes, charts, brushes, multiBrushes, tracker);\n  }\n\n}\nChartRow.defaultProps = {\n  trackerTimeFormat: \"%b %d %Y %X\",\n  enablePanZoom: false,\n  height: 100,\n  axisMargin: 5,\n  visible: true\n};\nChartRow.propTypes = {\n  /**\r\n   * The height of the row.\r\n   */\n  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n\n  /**\r\n   * The vertical margin between the top and bottom of the row\r\n   * height and the top and bottom of the range of the chart.\r\n   */\n  axisMargin: PropTypes.number,\n\n  /**\r\n   * Show or hide this row\r\n   */\n  visible: PropTypes.bool,\n\n  /**\r\n   * Should the time be shown on top of the tracker info box\r\n   */\n  trackerShowTime: PropTypes.bool,\n\n  /**\r\n   * The width of the tracker info box\r\n   */\n  trackerInfoWidth: PropTypes.number,\n\n  /**\r\n   * The height of the tracker info box\r\n   */\n  trackerInfoHeight: PropTypes.number,\n\n  /**\r\n   * Info box value or values to place next to the tracker line.\r\n   * This is either an array of objects, with each object\r\n   * specifying the label (a string) and value (also a string)\r\n   * to be shown in the info box, or a simple string label.\r\n   */\n  trackerInfoValues: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.shape({\n    label: PropTypes.string,\n    // eslint-disable-line\n    value: PropTypes.string // eslint-disable-line\n\n  }))]),\n\n  /**\r\n   * Specify the title for the chart row\r\n   */\n  title: PropTypes.string,\n\n  /**\r\n   * Specify the height of the title\r\n   * Default value is 28 pixels\r\n   */\n  titleHeight: PropTypes.number,\n\n  /**\r\n   * Specify the styling of the chart row's title\r\n   */\n  titleStyle: PropTypes.object,\n\n  /**\r\n   * Specify the styling of the box behind chart row's title\r\n   */\n  titleBoxStyle: PropTypes.object,\n  children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]),\n  leftAxisWidths: PropTypes.arrayOf(PropTypes.number),\n  rightAxisWidths: PropTypes.arrayOf(PropTypes.number),\n  width: PropTypes.number,\n  timeScale: PropTypes.func,\n  trackerTimeFormat: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n  timeFormat: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n  trackerTime: PropTypes.instanceOf(Date)\n};","map":{"version":3,"sources":["C:\\Users\\golde\\resin\\src\\ChartRow.js"],"names":["_","React","PropTypes","easeSinOut","scaleLinear","scaleLog","scalePow","areComponentsEqual","Brush","YAxis","Charts","MultiBrush","TimeMarker","ScaleInterpolator","createScale","yaxis","type","min","max","y0","y1","scale","isUndefined","domain","range","nice","base","props","logBase","power","powerExponent","exponent","ChartRow","Component","constructor","isChildYAxis","child","has","clipId","uniqueId","clipPathURL","state","mounted","updateScales","axisMargin","innerHeight","height","rangeTop","rangeBottom","Children","forEach","children","id","transition","scaleMap","s","yAxisScalerMap","setState","yScale","cacheKey","setScale","scalerMap","interpolator","scaler","componentWillMount","componentWillReceiveProps","nextProps","componentWillUnmount","render","paddingLeft","paddingRight","axes","chartList","yAxisMap","leftAxisList","rightAxisList","alignLeft","visible","push","reverse","transform","axis","posx","leftWidth","reduce","leftAxisWidths","a","b","rightWidth","rightAxisWidths","chartWidth","width","leftColumnIndex","length","colWidth","chartExtent","isInnerAxis","align","latestScale","cloneElement","rightColumnIndex","chartTransform","keyCount","charts","chart","ytransition","chartProps","key","timeScale","timeFormat","brushList","multiBrushList","brushProps","clipper","strokeOpacity","brushes","multiBrushes","tracker","trackerTime","trackerTimeFormat","timeMarkerProps","showLine","showTime","trackerShowTime","time","infoStyle","trackerStyle","trackerInfoValues","infoWidth","trackerInfoWidth","infoHeight","trackerInfoHeight","infoValues","pointerEvents","trackerTransform","defaultProps","enablePanZoom","propTypes","oneOfType","string","number","bool","arrayOf","shape","label","value","title","titleHeight","titleStyle","object","titleBoxStyle","node","func","instanceOf","Date"],"mappings":";;AAAA;;;;;;;;;AAUA,OAAOA,CAAP,MAAc,YAAd;AACA,OAAOC,KAAP,MAAkB,OAAlB;AACA,OAAOC,SAAP,MAAsB,YAAtB;AACA,SAASC,UAAT,QAA2B,SAA3B;AACA,SAASC,WAAT,EAAsBC,QAAtB,EAAgCC,QAAhC,QAAgD,UAAhD;AACA,SAASC,kBAAT,QAAmC,kBAAnC;AAEA,OAAOC,KAAP,MAAkB,SAAlB;AACA,OAAOC,KAAP,MAAkB,SAAlB;AACA,OAAOC,MAAP,MAAmB,UAAnB;AACA,OAAOC,UAAP,MAAuB,cAAvB;AACA,OAAOC,UAAP,MAAuB,cAAvB;AACA,OAAOC,iBAAP,MAA8B,uBAA9B;;AAEA,SAASC,WAAT,CAAqBC,KAArB,EAA4BC,IAA5B,EAAkCC,GAAlC,EAAuCC,GAAvC,EAA4CC,EAA5C,EAAgDC,EAAhD,EAAoD;AAClD,MAAIC,KAAJ;;AACA,MAAIrB,CAAC,CAACsB,WAAF,CAAcL,GAAd,KAAsBjB,CAAC,CAACsB,WAAF,CAAcJ,GAAd,CAA1B,EAA8C;AAC5CG,IAAAA,KAAK,GAAG,IAAR;AACD,GAFD,MAEO,IAAIL,IAAI,KAAK,QAAb,EAAuB;AAC5BK,IAAAA,KAAK,GAAGjB,WAAW,GAChBmB,MADK,CACE,CAACN,GAAD,EAAMC,GAAN,CADF,EAELM,KAFK,CAEC,CAACL,EAAD,EAAKC,EAAL,CAFD,EAGLK,IAHK,EAAR;AAID,GALM,MAKA,IAAIT,IAAI,KAAK,KAAb,EAAoB;AACzB,UAAMU,IAAI,GAAGX,KAAK,CAACY,KAAN,CAAYC,OAAZ,IAAuB,EAApC;AACAP,IAAAA,KAAK,GAAGhB,QAAQ,GACbqB,IADK,CACAA,IADA,EAELH,MAFK,CAEE,CAACN,GAAD,EAAMC,GAAN,CAFF,EAGLM,KAHK,CAGC,CAACL,EAAD,EAAKC,EAAL,CAHD,CAAR;AAID,GANM,MAMA,IAAIJ,IAAI,KAAK,OAAb,EAAsB;AAC3B,UAAMa,KAAK,GAAGd,KAAK,CAACY,KAAN,CAAYG,aAAZ,IAA6B,CAA3C;AACAT,IAAAA,KAAK,GAAGf,QAAQ,GACbyB,QADK,CACIF,KADJ,EAELN,MAFK,CAEE,CAACN,GAAD,EAAMC,GAAN,CAFF,EAGLM,KAHK,CAGC,CAACL,EAAD,EAAKC,EAAL,CAHD,CAAR;AAID;;AACD,SAAOC,KAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,eAAe,MAAMW,QAAN,SAAuB/B,KAAK,CAACgC,SAA7B,CAAuC;AACpDC,EAAAA,WAAW,CAACP,KAAD,EAAQ;AACjB,UAAMA,KAAN,EADiB,CAGjB;AACA;AACA;AACA;;AANiB,SAgBnBQ,YAhBmB,GAgBJC,KAAK,IAClB7B,kBAAkB,CAAC6B,KAAK,CAACpB,IAAP,EAAaP,KAAb,CAAlB,IACCT,CAAC,CAACqC,GAAF,CAAMD,KAAK,CAACT,KAAZ,EAAmB,KAAnB,KAA6B3B,CAAC,CAACqC,GAAF,CAAMD,KAAK,CAACT,KAAZ,EAAmB,KAAnB,CAlBb;;AAOjB,UAAMW,MAAM,GAAGtC,CAAC,CAACuC,QAAF,CAAW,OAAX,CAAf;;AACA,UAAMC,WAAW,kBAAWF,MAAX,MAAjB;AACA,SAAKG,KAAL,GAAa;AACXH,MAAAA,MADW;AAEXE,MAAAA;AAFW,KAAb;AAIA,SAAKE,OAAL,GAAe,IAAf;AACD;;AAMDC,EAAAA,YAAY,CAAChB,KAAD,EAAQ;AAClB,UAAMiB,UAAU,GAAGjB,KAAK,CAACiB,UAAzB;AACA,UAAMC,WAAW,GAAG,CAAClB,KAAK,CAACmB,MAAP,GAAgBF,UAAU,GAAG,CAAjD;AACA,UAAMG,QAAQ,GAAGH,UAAjB;AACA,UAAMI,WAAW,GAAGH,WAAW,GAAGD,UAAlC;AACA3C,IAAAA,KAAK,CAACgD,QAAN,CAAeC,OAAf,CAAuBvB,KAAK,CAACwB,QAA7B,EAAuCf,KAAK,IAAI;AAC9C,UAAIA,KAAK,KAAK,IAAd,EAAoB;;AACpB,UAAI,KAAKD,YAAL,CAAkBC,KAAlB,CAAJ,EAA8B;AAAA,6BAC8BA,KAAK,CAACT,KADpC;AAAA,cACpByB,EADoB,gBACpBA,EADoB;AAAA,cAChBlC,GADgB,gBAChBA,GADgB;AAAA,cACXD,GADW,gBACXA,GADW;AAAA,mDACNoC,UADM;AAAA,cACNA,UADM,sCACO,CADP;AAAA,+CACUrC,IADV;AAAA,cACUA,IADV,kCACiB,QADjB;;AAE5B,YAAI,CAAChB,CAAC,CAACqC,GAAF,CAAM,KAAKiB,QAAX,EAAqBF,EAArB,CAAL,EAA+B;AAC7B;AACA;AACA,eAAKE,QAAL,CAAcF,EAAd,IAAoB,IAAIvC,iBAAJ,CAClBwC,UADkB,EAElBlD,UAFkB,EAGlBoD,CAAC,IAAI;AACH,kBAAMC,cAAc,GAAG,KAAKf,KAAL,CAAWe,cAAlC;AACAA,YAAAA,cAAc,CAACJ,EAAD,CAAd,GAAqBG,CAArB;AACA,gBAAI,KAAKb,OAAT,EAAkB,KAAKe,QAAL,CAAcD,cAAd;AACnB,WAPiB,CAApB;AASD,SAd2B,CAe5B;;;AACA,YAAInC,KAAJ;;AACA,YAAIrB,CAAC,CAACqC,GAAF,CAAMD,KAAK,CAACT,KAAZ,EAAmB,QAAnB,CAAJ,EAAkC;AAChC;AACAN,UAAAA,KAAK,GAAGe,KAAK,CAACT,KAAN,CAAY+B,MAApB;AACD,SAHD,MAGO;AACL;AACArC,UAAAA,KAAK,GAAGP,WAAW,CAACsB,KAAD,EAAQpB,IAAR,EAAcC,GAAd,EAAmBC,GAAnB,EAAwB8B,WAAxB,EAAqCD,QAArC,CAAnB;AACD,SAvB2B,CAyB5B;;;AACA,cAAMY,QAAQ,aAAM3C,IAAN,cAAcC,GAAd,cAAqBC,GAArB,cAA4B8B,WAA5B,cAA2CD,QAA3C,CAAd;AACA,aAAKO,QAAL,CAAcF,EAAd,EAAkBQ,QAAlB,CAA2BD,QAA3B,EAAqCtC,KAArC;AACD;AACF,KA/BD,EALkB,CAsClB;;AACA,UAAMwC,SAAS,GAAG,EAAlB;;AACA7D,IAAAA,CAAC,CAACkD,OAAF,CAAU,KAAKI,QAAf,EAAyB,CAACQ,YAAD,EAAeV,EAAf,KAAsB;AAC7CS,MAAAA,SAAS,CAACT,EAAD,CAAT,GAAgBU,YAAY,CAACC,MAAb,EAAhB;AACD,KAFD;;AAIA,QAAI,KAAKrB,OAAT,EAAkB,KAAKe,QAAL,CAAc;AAAED,MAAAA,cAAc,EAAEK;AAAlB,KAAd;AACnB;;AAEDG,EAAAA,kBAAkB,GAAG;AACnB;AACA;AACA;AACA;AACA;AACA,SAAKV,QAAL,GAAgB,EAAhB;AACA,SAAKX,YAAL,CAAkB,KAAKhB,KAAvB;AACD;AAED;;;;;;AAIAsC,EAAAA,yBAAyB,CAACC,SAAD,EAAY;AACnC,SAAKvB,YAAL,CAAkBuB,SAAlB;AACD;;AACDC,EAAAA,oBAAoB,GAAG;AACrB,SAAKzB,OAAL,GAAe,KAAf;AACD;;AACD0B,EAAAA,MAAM,GAAG;AAAA,wBAC+B,KAAKzC,KADpC;AAAA,UACC0C,WADD,eACCA,WADD;AAAA,UACcC,YADd,eACcA,YADd;AAGP,UAAMC,IAAI,GAAG,EAAb,CAHO,CAGU;;AACjB,UAAMC,SAAS,GAAG,EAAlB,CAJO,CAIe;AACtB;;AACA,UAAM3B,WAAW,GAAG,CAAC,KAAKlB,KAAL,CAAWmB,MAAZ,GAAqB,KAAKnB,KAAL,CAAWiB,UAAX,GAAwB,CAAjE,CANO,CAQP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAM6B,QAAQ,GAAG,EAAjB,CApBO,CAoBc;;AACrB,UAAMC,YAAY,GAAG,EAArB,CArBO,CAqBkB;;AACzB,UAAMC,aAAa,GAAG,EAAtB,CAtBO,CAsBmB;;AAC1B,QAAIC,SAAS,GAAG,IAAhB;AACA3E,IAAAA,KAAK,CAACgD,QAAN,CAAeC,OAAf,CAAuB,KAAKvB,KAAL,CAAWwB,QAAlC,EAA4Cf,KAAK,IAAI;AACnD,UAAIA,KAAK,KAAK,IAAd,EAAoB;;AACpB,UAAI7B,kBAAkB,CAAC6B,KAAK,CAACpB,IAAP,EAAaN,MAAb,CAAtB,EAA4C;AAC1CkE,QAAAA,SAAS,GAAG,KAAZ;AACD,OAFD,MAEO;AACL,cAAMxB,EAAE,GAAGhB,KAAK,CAACT,KAAN,CAAYyB,EAAvB,CADK,CAEL;;AACA,YAAI,KAAKjB,YAAL,CAAkBC,KAAlB,CAAJ,EAA8B;AAC5B,gBAAMrB,KAAK,GAAGqB,KAAd;;AAEA,cAAIrB,KAAK,CAACY,KAAN,CAAYyB,EAAZ,IAAkBrC,KAAK,CAACY,KAAN,CAAYkD,OAAZ,KAAwB,KAA9C,EAAqD;AACnD;AACAJ,YAAAA,QAAQ,CAAC1D,KAAK,CAACY,KAAN,CAAYyB,EAAb,CAAR,GAA2BrC,KAA3B;AACD,WAN2B,CAQ5B;;;AACA,cAAI6D,SAAJ,EAAe;AACbF,YAAAA,YAAY,CAACI,IAAb,CAAkB1B,EAAlB;AACD,WAFD,MAEO;AACLuB,YAAAA,aAAa,CAACG,IAAd,CAAmB1B,EAAnB;AACD;AACF;AACF;AACF,KAvBD,EAxBO,CAiDP;;AACAsB,IAAAA,YAAY,CAACK,OAAb,GAlDO,CAoDP;AACA;AACA;AACA;;AAEA,QAAIC,SAAJ;AACA,QAAI5B,EAAJ;AACA,QAAIzB,KAAJ;AACA,QAAIsD,IAAJ;AACA,QAAIC,IAAI,GAAG,CAAX,CA7DO,CA+DP;;AACA,UAAMC,SAAS,GAAGnF,CAAC,CAACoF,MAAF,CAAS,KAAKzD,KAAL,CAAW0D,cAApB,EAAoC,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAAlD,EAAqD,CAArD,CAAlB;;AACA,UAAMC,UAAU,GAAGxF,CAAC,CAACoF,MAAF,CAAS,KAAKzD,KAAL,CAAW8D,eAApB,EAAqC,CAACH,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAAnD,EAAsD,CAAtD,CAAnB;;AACA,UAAMG,UAAU,GACd,KAAK/D,KAAL,CAAWgE,KAAX,GAAmBR,SAAnB,GAA+BK,UAA/B,GAA4CnB,WAA5C,GAA0DC,YAD5D;AAGAY,IAAAA,IAAI,GAAGC,SAAP;;AACA,SACE,IAAIS,eAAe,GAAG,CADxB,EAEEA,eAAe,GAAG,KAAKjE,KAAL,CAAW0D,cAAX,CAA0BQ,MAF9C,EAGED,eAAe,IAAI,CAHrB,EAIE;AACA,YAAME,QAAQ,GAAG,KAAKnE,KAAL,CAAW0D,cAAX,CAA0BO,eAA1B,CAAjB;AACAV,MAAAA,IAAI,IAAIY,QAAR;;AACA,UAAIA,QAAQ,GAAG,CAAX,IAAgBF,eAAe,GAAGlB,YAAY,CAACmB,MAAnD,EAA2D;AACzDzC,QAAAA,EAAE,GAAGsB,YAAY,CAACkB,eAAD,CAAjB;;AACA,YAAI5F,CAAC,CAACqC,GAAF,CAAMoC,QAAN,EAAgBrB,EAAhB,CAAJ,EAAyB;AACvB4B,UAAAA,SAAS,uBAAgBE,IAAI,GAAGb,WAAvB,QAAT,CADuB,CAGvB;;AACA1C,UAAAA,KAAK,GAAG;AACNgE,YAAAA,KAAK,EAAEG,QADD;AAENhD,YAAAA,MAAM,EAAED,WAFF;AAGNkD,YAAAA,WAAW,EAAEL,UAHP;AAINM,YAAAA,WAAW,EAAEJ,eAAe,KAAK,CAJ3B;AAKNK,YAAAA,KAAK,EAAE,MALD;AAMN5E,YAAAA,KAAK,EAAE,KAAKiC,QAAL,CAAcF,EAAd,EAAkB8C,WAAlB;AAND,WAAR,CAJuB,CAavB;;AACAjB,UAAAA,IAAI,GAAGhF,KAAK,CAACkG,YAAN,CAAmB1B,QAAQ,CAACrB,EAAD,CAA3B,EAAiCzB,KAAjC,CAAP;AAEA4C,UAAAA,IAAI,CAACO,IAAL,CACE;AAAG,YAAA,GAAG,wBAAiBc,eAAjB,CAAN;AAA0C,YAAA,SAAS,EAAEZ,SAArD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aACGC,IADH,CADF;AAKD;AACF;AACF;;AAEDC,IAAAA,IAAI,GAAG,KAAKvD,KAAL,CAAWgE,KAAX,GAAmBH,UAAnB,GAAgClB,YAAvC;;AACA,SACE,IAAI8B,gBAAgB,GAAG,CADzB,EAEEA,gBAAgB,GAAG,KAAKzE,KAAL,CAAW8D,eAAX,CAA2BI,MAFhD,EAGEO,gBAAgB,IAAI,CAHtB,EAIE;AACA,YAAMN,QAAQ,GAAG,KAAKnE,KAAL,CAAW8D,eAAX,CAA2BW,gBAA3B,CAAjB;;AACA,UAAIN,QAAQ,GAAG,CAAX,IAAgBM,gBAAgB,GAAGzB,aAAa,CAACkB,MAArD,EAA6D;AAC3DzC,QAAAA,EAAE,GAAGuB,aAAa,CAACyB,gBAAD,CAAlB;;AACA,YAAIpG,CAAC,CAACqC,GAAF,CAAMoC,QAAN,EAAgBrB,EAAhB,CAAJ,EAAyB;AACvB4B,UAAAA,SAAS,uBAAgBE,IAAI,GAAGb,WAAvB,QAAT,CADuB,CAGvB;;AACA1C,UAAAA,KAAK,GAAG;AACNgE,YAAAA,KAAK,EAAEG,QADD;AAENhD,YAAAA,MAAM,EAAED,WAFF;AAGNkD,YAAAA,WAAW,EAAEL,UAHP;AAIN;AACAM,YAAAA,WAAW,EAAEI,gBAAgB,KAAK,CAL5B;AAMNH,YAAAA,KAAK,EAAE,OAND;AAON5E,YAAAA,KAAK,EAAE,KAAKiC,QAAL,CAAcF,EAAd,EAAkB8C,WAAlB;AAPD,WAAR,CAJuB,CAcvB;;AACAjB,UAAAA,IAAI,GAAGhF,KAAK,CAACkG,YAAN,CAAmB1B,QAAQ,CAACrB,EAAD,CAA3B,EAAiCzB,KAAjC,CAAP;AAEA4C,UAAAA,IAAI,CAACO,IAAL,CACE;AAAG,YAAA,GAAG,yBAAkBsB,gBAAlB,CAAN;AAA4C,YAAA,SAAS,EAAEpB,SAAvD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aACGC,IADH,CADF;AAKD;AACF;;AAEDC,MAAAA,IAAI,IAAIY,QAAR;AACD,KA3IM,CA6IP;AACA;AACA;AACA;AACA;AACA;;;AAEA,UAAMO,cAAc,uBAAgBlB,SAAS,GAAGd,WAA5B,QAApB;AAEA,QAAIiC,QAAQ,GAAG,CAAf;AACArG,IAAAA,KAAK,CAACgD,QAAN,CAAeC,OAAf,CAAuB,KAAKvB,KAAL,CAAWwB,QAAlC,EAA4Cf,KAAK,IAAI;AACnD,UAAIA,KAAK,KAAK,IAAd,EAAoB;;AACpB,UAAI7B,kBAAkB,CAAC6B,KAAK,CAACpB,IAAP,EAAaN,MAAb,CAAtB,EAA4C;AAC1C,cAAM6F,MAAM,GAAGnE,KAAf;AACAnC,QAAAA,KAAK,CAACgD,QAAN,CAAeC,OAAf,CAAuBqD,MAAM,CAAC5E,KAAP,CAAawB,QAApC,EAA8CqD,KAAK,IAAI;AACrD,cAAI,CAACxG,CAAC,CAACqC,GAAF,CAAMmE,KAAK,CAAC7E,KAAZ,EAAmB,SAAnB,CAAD,IAAkC6E,KAAK,CAAC7E,KAAN,CAAYkD,OAAlD,EAA2D;AACzD,gBAAIxD,KAAK,GAAG,IAAZ;;AACA,gBAAIrB,CAAC,CAACqC,GAAF,CAAM,KAAKI,KAAL,CAAWe,cAAjB,EAAiCgD,KAAK,CAAC7E,KAAN,CAAYsD,IAA7C,CAAJ,EAAwD;AACtD5D,cAAAA,KAAK,GAAG,KAAKoB,KAAL,CAAWe,cAAX,CAA0BgD,KAAK,CAAC7E,KAAN,CAAYsD,IAAtC,CAAR;AACD;;AAED,gBAAIwB,WAAW,GAAG,IAAlB;;AACA,gBAAIzG,CAAC,CAACqC,GAAF,CAAM,KAAKiB,QAAX,EAAqBkD,KAAK,CAAC7E,KAAN,CAAYsD,IAAjC,CAAJ,EAA4C;AAC1CwB,cAAAA,WAAW,GAAG,KAAKnD,QAAL,CAAckD,KAAK,CAAC7E,KAAN,CAAYsD,IAA1B,CAAd;AACD;;AAED,kBAAMyB,UAAU,GAAG;AACjBC,cAAAA,GAAG,EAAEL,QADY;AAEjBX,cAAAA,KAAK,EAAED,UAFU;AAGjB5C,cAAAA,MAAM,EAAED,WAHS;AAIjB+D,cAAAA,SAAS,EAAE,KAAKjF,KAAL,CAAWiF,SAJL;AAKjBC,cAAAA,UAAU,EAAE,KAAKlF,KAAL,CAAWkF;AALN,aAAnB;;AAQA,gBAAIxF,KAAJ,EAAW;AACTqF,cAAAA,UAAU,CAAChD,MAAX,GAAoBrC,KAApB;AACD;;AAED,gBAAIoF,WAAJ,EAAiB;AACfC,cAAAA,UAAU,CAACrD,UAAX,GAAwBoD,WAAxB;AACD;;AAEDjC,YAAAA,SAAS,CAACM,IAAV,CAAe7E,KAAK,CAACkG,YAAN,CAAmBK,KAAnB,EAA0BE,UAA1B,CAAf;AACAJ,YAAAA,QAAQ,IAAI,CAAZ;AACD;AACF,SA/BD;AAgCD;AACF,KArCD,EAvJO,CA8LP;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAMQ,SAAS,GAAG,EAAlB;AACA,UAAMC,cAAc,GAAG,EAAvB;AACAT,IAAAA,QAAQ,GAAG,CAAX;AACArG,IAAAA,KAAK,CAACgD,QAAN,CAAeC,OAAf,CAAuB,KAAKvB,KAAL,CAAWwB,QAAlC,EAA4Cf,KAAK,IAAI;AACnD,UAAIA,KAAK,KAAK,IAAd,EAAoB;;AACpB,UACE7B,kBAAkB,CAAC6B,KAAK,CAACpB,IAAP,EAAaR,KAAb,CAAlB,IACAD,kBAAkB,CAAC6B,KAAK,CAACpB,IAAP,EAAaL,UAAb,CAFpB,EAGE;AACA,cAAMqG,UAAU,GAAG;AACjBL,UAAAA,GAAG,kBAAWL,QAAX,CADc;AAEjBX,UAAAA,KAAK,EAAED,UAFU;AAGjB5C,UAAAA,MAAM,EAAED,WAHS;AAIjB+D,UAAAA,SAAS,EAAE,KAAKjF,KAAL,CAAWiF;AAJL,SAAnB;;AAMA,YAAIrG,kBAAkB,CAAC6B,KAAK,CAACpB,IAAP,EAAaR,KAAb,CAAtB,EAA2C;AACzCsG,UAAAA,SAAS,CAAChC,IAAV,CAAe7E,KAAK,CAACkG,YAAN,CAAmB/D,KAAnB,EAA0B4E,UAA1B,CAAf;AACD,SAFD,MAEO;AACLD,UAAAA,cAAc,CAACjC,IAAf,CAAoB7E,KAAK,CAACkG,YAAN,CAAmB/D,KAAnB,EAA0B4E,UAA1B,CAApB;AACD;AACF;;AACDV,MAAAA,QAAQ,IAAI,CAAZ;AACD,KAnBD;AAqBA,UAAMC,MAAM,GACV;AAAG,MAAA,SAAS,EAAEF,cAAd;AAA8B,MAAA,GAAG,EAAC,kBAAlC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACE;AAAG,MAAA,GAAG,EAAC,QAAP;AAAgB,MAAA,QAAQ,EAAE,KAAK5D,KAAL,CAAWD,WAArC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACGgC,SADH,CADF,CADF,CA7NO,CAqOP;AACA;AACA;;AACA,UAAMyC,OAAO,GACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACE;AAAU,MAAA,EAAE,EAAE,KAAKxE,KAAL,CAAWH,MAAzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACE;AACE,MAAA,CAAC,EAAC,GADJ;AAEE,MAAA,CAAC,EAAC,GAFJ;AAGE,MAAA,KAAK,EAAE;AAAE4E,QAAAA,aAAa,EAAE;AAAjB,OAHT;AAIE,MAAA,KAAK,EAAExB,UAJT;AAKE,MAAA,MAAM,EAAE7C,WALV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MADF,CADF,CADF,CAxOO,CAsPP;AACA;AACA;;AACA,UAAMsE,OAAO,GACX;AAAG,MAAA,SAAS,EAAEd,cAAd;AAA8B,MAAA,GAAG,EAAC,aAAlC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACGS,SADH,CADF,CAzPO,CA+PP;AACA;AACA;;AACA,UAAMM,YAAY,GAChB;AAAG,MAAA,SAAS,EAAEf,cAAd;AAA8B,MAAA,GAAG,EAAC,mBAAlC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACGU,cADH,CADF,CAlQO,CAwQP;AACA;AACA;;AACA,QAAIM,OAAJ;;AACA,QAAI,KAAK1F,KAAL,CAAW2F,WAAf,EAA4B;AAC1B,YAAMT,UAAU,GAAG,KAAKlF,KAAL,CAAW4F,iBAAX,IAAgC,KAAK5F,KAAL,CAAWkF,UAA9D;AACA,YAAMW,eAAe,GAAG;AACtBX,QAAAA,UADsB;AAEtBY,QAAAA,QAAQ,EAAE,KAFY;AAGtBC,QAAAA,QAAQ,EAAE,KAAK/F,KAAL,CAAWgG,eAHC;AAItBC,QAAAA,IAAI,EAAE,KAAKjG,KAAL,CAAW2F,WAJK;AAKtBV,QAAAA,SAAS,EAAE,KAAKjF,KAAL,CAAWiF,SALA;AAMtBjB,QAAAA,KAAK,EAAED,UANe;AAOtBmC,QAAAA,SAAS,EAAE,KAAKlG,KAAL,CAAWmG;AAPA,OAAxB;;AASA,UAAI,KAAKnG,KAAL,CAAWoG,iBAAf,EAAkC;AAChCP,QAAAA,eAAe,CAACQ,SAAhB,GAA4B,KAAKrG,KAAL,CAAWsG,gBAAvC;AACAT,QAAAA,eAAe,CAACU,UAAhB,GAA6B,KAAKvG,KAAL,CAAWwG,iBAAxC;AACAX,QAAAA,eAAe,CAACY,UAAhB,GAA6B,KAAKzG,KAAL,CAAWoG,iBAAxC;AACAP,QAAAA,eAAe,CAACX,UAAhB,GAA6B,KAAKlF,KAAL,CAAW4F,iBAAxC;AACD;;AACD,YAAMO,YAAY,GAAG;AACnBO,QAAAA,aAAa,EAAE;AADI,OAArB;AAGA,YAAMC,gBAAgB,uBAAgBnD,SAAS,GAAGd,WAA5B,QAAtB;AAEAgD,MAAAA,OAAO,GACL;AACE,QAAA,GAAG,EAAC,eADN;AAEE,QAAA,KAAK,EAAES,YAFT;AAGE,QAAA,SAAS,EAAEQ,gBAHb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAKE,oBAAC,UAAD,oBAAgBd,eAAhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SALF,CADF;AASD;;AAED,WACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACGP,OADH,EAEG1C,IAFH,EAGGgC,MAHH,EAIGY,OAJH,EAKGC,YALH,EAMGC,OANH,CADF;AAUD;;AA/YmD;AAkZtDrF,QAAQ,CAACuG,YAAT,GAAwB;AACtBhB,EAAAA,iBAAiB,EAAE,aADG;AAEtBiB,EAAAA,aAAa,EAAE,KAFO;AAGtB1F,EAAAA,MAAM,EAAE,GAHc;AAItBF,EAAAA,UAAU,EAAE,CAJU;AAKtBiC,EAAAA,OAAO,EAAE;AALa,CAAxB;AAQA7C,QAAQ,CAACyG,SAAT,GAAqB;AACnB;;;AAGA3F,EAAAA,MAAM,EAAE5C,SAAS,CAACwI,SAAV,CAAoB,CAACxI,SAAS,CAACyI,MAAX,EAAmBzI,SAAS,CAAC0I,MAA7B,CAApB,CAJW;;AAMnB;;;;AAIAhG,EAAAA,UAAU,EAAE1C,SAAS,CAAC0I,MAVH;;AAYnB;;;AAGA/D,EAAAA,OAAO,EAAE3E,SAAS,CAAC2I,IAfA;;AAiBnB;;;AAGAlB,EAAAA,eAAe,EAAEzH,SAAS,CAAC2I,IApBR;;AAsBnB;;;AAGAZ,EAAAA,gBAAgB,EAAE/H,SAAS,CAAC0I,MAzBT;;AA2BnB;;;AAGAT,EAAAA,iBAAiB,EAAEjI,SAAS,CAAC0I,MA9BV;;AAgCnB;;;;;;AAMAb,EAAAA,iBAAiB,EAAE7H,SAAS,CAACwI,SAAV,CAAoB,CACrCxI,SAAS,CAACyI,MAD2B,EAErCzI,SAAS,CAAC4I,OAAV,CACE5I,SAAS,CAAC6I,KAAV,CAAgB;AACdC,IAAAA,KAAK,EAAE9I,SAAS,CAACyI,MADH;AACW;AACzBM,IAAAA,KAAK,EAAE/I,SAAS,CAACyI,MAFH,CAEU;;AAFV,GAAhB,CADF,CAFqC,CAApB,CAtCA;;AAgDnB;;;AAGAO,EAAAA,KAAK,EAAEhJ,SAAS,CAACyI,MAnDE;;AAqDnB;;;;AAIAQ,EAAAA,WAAW,EAAEjJ,SAAS,CAAC0I,MAzDJ;;AA2DnB;;;AAGAQ,EAAAA,UAAU,EAAElJ,SAAS,CAACmJ,MA9DH;;AAgEnB;;;AAGAC,EAAAA,aAAa,EAAEpJ,SAAS,CAACmJ,MAnEN;AAqEnBlG,EAAAA,QAAQ,EAAEjD,SAAS,CAACwI,SAAV,CAAoB,CAC5BxI,SAAS,CAAC4I,OAAV,CAAkB5I,SAAS,CAACqJ,IAA5B,CAD4B,EAE5BrJ,SAAS,CAACqJ,IAFkB,CAApB,CArES;AAyEnBlE,EAAAA,cAAc,EAAEnF,SAAS,CAAC4I,OAAV,CAAkB5I,SAAS,CAAC0I,MAA5B,CAzEG;AA0EnBnD,EAAAA,eAAe,EAAEvF,SAAS,CAAC4I,OAAV,CAAkB5I,SAAS,CAAC0I,MAA5B,CA1EE;AA2EnBjD,EAAAA,KAAK,EAAEzF,SAAS,CAAC0I,MA3EE;AA4EnBhC,EAAAA,SAAS,EAAE1G,SAAS,CAACsJ,IA5EF;AA6EnBjC,EAAAA,iBAAiB,EAAErH,SAAS,CAACwI,SAAV,CAAoB,CAACxI,SAAS,CAACyI,MAAX,EAAmBzI,SAAS,CAACsJ,IAA7B,CAApB,CA7EA;AA8EnB3C,EAAAA,UAAU,EAAE3G,SAAS,CAACwI,SAAV,CAAoB,CAACxI,SAAS,CAACyI,MAAX,EAAmBzI,SAAS,CAACsJ,IAA7B,CAApB,CA9EO;AA+EnBlC,EAAAA,WAAW,EAAEpH,SAAS,CAACuJ,UAAV,CAAqBC,IAArB;AA/EM,CAArB","sourcesContent":["/**\r\n *  Copyright (c) 2015-present, The Regents of the University of California,\r\n *  through Lawrence Berkeley National Laboratory (subject to receipt\r\n *  of any required approvals from the U.S. Dept. of Energy).\r\n *  All rights reserved.\r\n *\r\n *  This source code is licensed under the BSD-style license found in the\r\n *  LICENSE file in the root directory of this source tree.\r\n */\r\n\r\nimport _ from \"underscore\";\r\nimport React from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport { easeSinOut } from \"d3-ease\";\r\nimport { scaleLinear, scaleLog, scalePow } from \"d3-scale\";\r\nimport { areComponentsEqual } from \"react-hot-loader\";\r\n\r\nimport Brush from \"./Brush\";\r\nimport YAxis from \"./YAxis\";\r\nimport Charts from \"./Charts\";\r\nimport MultiBrush from \"./MultiBrush\";\r\nimport TimeMarker from \"./TimeMarker\";\r\nimport ScaleInterpolator from \"./utils/interpolators\";\r\n\r\nfunction createScale(yaxis, type, min, max, y0, y1) {\r\n  let scale;\r\n  if (_.isUndefined(min) || _.isUndefined(max)) {\r\n    scale = null;\r\n  } else if (type === \"linear\") {\r\n    scale = scaleLinear()\r\n      .domain([min, max])\r\n      .range([y0, y1])\r\n      .nice();\r\n  } else if (type === \"log\") {\r\n    const base = yaxis.props.logBase || 10;\r\n    scale = scaleLog()\r\n      .base(base)\r\n      .domain([min, max])\r\n      .range([y0, y1]);\r\n  } else if (type === \"power\") {\r\n    const power = yaxis.props.powerExponent || 2;\r\n    scale = scalePow()\r\n      .exponent(power)\r\n      .domain([min, max])\r\n      .range([y0, y1]);\r\n  }\r\n  return scale;\r\n}\r\n\r\n/**\r\n * A ChartRow is a container for a set of YAxis and multiple charts\r\n * which are overlaid on each other in a central canvas.\r\n *\r\n * Here is an example where a single `<ChartRow>` is defined within\r\n * the `<ChartContainer>`. Of course you can have any number of rows.\r\n *\r\n * For this row we specify the one prop `height` as 200 pixels high.\r\n *\r\n * Within the `<ChartRow>` we add:\r\n *\r\n * * `<YAxis>` elements for axes to the left of the chart\r\n * * `<Chart>` block containing our central chart area\r\n * * `<YAxis>` elements for our axes to the right of the charts\r\n *\r\n * ```\r\n * <ChartContainer timeRange={audSeries.timerange()}>\r\n *     <ChartRow height=\"200\">\r\n *         <YAxis />\r\n *         <YAxis />\r\n *         <Charts>\r\n *             charts...\r\n *        </Charts>\r\n *         <YAxis />\r\n *     </ChartRow>\r\n * </ChartContainer>\r\n * ```\r\n */\r\nexport default class ChartRow extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    // id of clipping rectangle we will generate and use for each child\r\n    // chart. Lives in state to ensure just one clipping rectangle and\r\n    // id per chart row instance; we don't want a fresh id generated on\r\n    // each render.\r\n    const clipId = _.uniqueId(\"clip_\");\r\n    const clipPathURL = `url(#${clipId})`;\r\n    this.state = {\r\n      clipId,\r\n      clipPathURL\r\n    };\r\n    this.mounted = true;\r\n  }\r\n\r\n  isChildYAxis = child =>\r\n    areComponentsEqual(child.type, YAxis) ||\r\n    (_.has(child.props, \"min\") && _.has(child.props, \"max\"));\r\n\r\n  updateScales(props) {\r\n    const axisMargin = props.axisMargin;\r\n    const innerHeight = +props.height - axisMargin * 2;\r\n    const rangeTop = axisMargin;\r\n    const rangeBottom = innerHeight - axisMargin;\r\n    React.Children.forEach(props.children, child => {\r\n      if (child === null) return;\r\n      if (this.isChildYAxis(child)) {\r\n        const { id, max, min, transition = 0, type = \"linear\" } = child.props;\r\n        if (!_.has(this.scaleMap, id)) {\r\n          // If necessary, initialize a ScaleInterpolator for this y-axis.\r\n          // When the yScale changes, we will update this interpolator.\r\n          this.scaleMap[id] = new ScaleInterpolator(\r\n            transition,\r\n            easeSinOut,\r\n            s => {\r\n              const yAxisScalerMap = this.state.yAxisScalerMap;\r\n              yAxisScalerMap[id] = s;\r\n              if (this.mounted) this.setState(yAxisScalerMap);\r\n            }\r\n          );\r\n        }\r\n        // Get the vertical scale for this y-axis.\r\n        let scale;\r\n        if (_.has(child.props, \"yScale\")) {\r\n          // If the yScale prop is passed explicitly, use that.\r\n          scale = child.props.yScale;\r\n        } else {\r\n          // Otherwise, compute the scale based on the max and min props.\r\n          scale = createScale(child, type, min, max, rangeBottom, rangeTop);\r\n        }\r\n\r\n        // Update the scale on the interpolator for this y-axis.\r\n        const cacheKey = `${type}-${min}-${max}-${rangeBottom}-${rangeTop}`;\r\n        this.scaleMap[id].setScale(cacheKey, scale);\r\n      }\r\n    });\r\n\r\n    // Update the state with the newly interpolated scaler for each y-axis.\r\n    const scalerMap = {};\r\n    _.forEach(this.scaleMap, (interpolator, id) => {\r\n      scalerMap[id] = interpolator.scaler();\r\n    });\r\n\r\n    if (this.mounted) this.setState({ yAxisScalerMap: scalerMap });\r\n  }\r\n\r\n  componentWillMount() {\r\n    // Our chart scales are driven off a mapping between id of the axis\r\n    // and the scale that axis represents. Depending on the transition time,\r\n    // this scale will animate over time. The controller of this animation is\r\n    // the ScaleInterpolator. We create new Scale Interpolators here for each\r\n    // axis id.\r\n    this.scaleMap = {};\r\n    this.updateScales(this.props);\r\n  }\r\n\r\n  /**\r\n   * When we get changes to the row's props we update our map of\r\n   * axis scales.\r\n   */\r\n  componentWillReceiveProps(nextProps) {\r\n    this.updateScales(nextProps);\r\n  }\r\n  componentWillUnmount() {\r\n    this.mounted = false;\r\n  }\r\n  render() {\r\n    const { paddingLeft, paddingRight } = this.props;\r\n\r\n    const axes = []; // Contains all the yAxis elements used in the render\r\n    const chartList = []; // Contains all the Chart elements used in the render\r\n    // Dimensions\r\n    const innerHeight = +this.props.height - this.props.axisMargin * 2;\r\n\r\n    //\r\n    // Build a map of elements that occupy left or right slots next to the\r\n    // chart.\r\n    //\r\n    // If an element has both and id and a min/max range, then we consider\r\n    // it to be a y axis. For those we calculate a d3 scale that can be\r\n    // reference by a chart. That scale will also be available to the axis\r\n    // when it renders.\r\n    //\r\n    // For this row, we will need to know how many axis slots we are using.\r\n    //\r\n\r\n    const yAxisMap = {}; // Maps axis id -> axis element\r\n    const leftAxisList = []; // Ordered list of left axes ids\r\n    const rightAxisList = []; // Ordered list of right axes ids\r\n    let alignLeft = true;\r\n    React.Children.forEach(this.props.children, child => {\r\n      if (child === null) return;\r\n      if (areComponentsEqual(child.type, Charts)) {\r\n        alignLeft = false;\r\n      } else {\r\n        const id = child.props.id;\r\n        // Check to see if we think this 'axis' is actually an axis\r\n        if (this.isChildYAxis(child)) {\r\n          const yaxis = child;\r\n\r\n          if (yaxis.props.id && yaxis.props.visible !== false) {\r\n            // Relate id to the axis\r\n            yAxisMap[yaxis.props.id] = yaxis;\r\n          }\r\n\r\n          // Columns counts\r\n          if (alignLeft) {\r\n            leftAxisList.push(id);\r\n          } else {\r\n            rightAxisList.push(id);\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    // Since we'll be building the left axis items from the inside to the outside\r\n    leftAxisList.reverse();\r\n\r\n    //\r\n    // Push each axis onto the axes, transforming each into its\r\n    // column location\r\n    //\r\n\r\n    let transform;\r\n    let id;\r\n    let props;\r\n    let axis;\r\n    let posx = 0;\r\n\r\n    // Space used by columns on left and right of charts\r\n    const leftWidth = _.reduce(this.props.leftAxisWidths, (a, b) => a + b, 0);\r\n    const rightWidth = _.reduce(this.props.rightAxisWidths, (a, b) => a + b, 0);\r\n    const chartWidth =\r\n      this.props.width - leftWidth - rightWidth - paddingLeft - paddingRight;\r\n\r\n    posx = leftWidth;\r\n    for (\r\n      let leftColumnIndex = 0;\r\n      leftColumnIndex < this.props.leftAxisWidths.length;\r\n      leftColumnIndex += 1\r\n    ) {\r\n      const colWidth = this.props.leftAxisWidths[leftColumnIndex];\r\n      posx -= colWidth;\r\n      if (colWidth > 0 && leftColumnIndex < leftAxisList.length) {\r\n        id = leftAxisList[leftColumnIndex];\r\n        if (_.has(yAxisMap, id)) {\r\n          transform = `translate(${posx + paddingLeft},0)`;\r\n\r\n          // Additional props for left aligned axes\r\n          props = {\r\n            width: colWidth,\r\n            height: innerHeight,\r\n            chartExtent: chartWidth,\r\n            isInnerAxis: leftColumnIndex === 0,\r\n            align: \"left\",\r\n            scale: this.scaleMap[id].latestScale()\r\n          };\r\n\r\n          // Cloned left axis\r\n          axis = React.cloneElement(yAxisMap[id], props);\r\n\r\n          axes.push(\r\n            <g key={`y-axis-left-${leftColumnIndex}`} transform={transform}>\r\n              {axis}\r\n            </g>\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    posx = this.props.width - rightWidth - paddingRight;\r\n    for (\r\n      let rightColumnIndex = 0;\r\n      rightColumnIndex < this.props.rightAxisWidths.length;\r\n      rightColumnIndex += 1\r\n    ) {\r\n      const colWidth = this.props.rightAxisWidths[rightColumnIndex];\r\n      if (colWidth > 0 && rightColumnIndex < rightAxisList.length) {\r\n        id = rightAxisList[rightColumnIndex];\r\n        if (_.has(yAxisMap, id)) {\r\n          transform = `translate(${posx + paddingLeft},0)`;\r\n\r\n          // Additional props for right aligned axes\r\n          props = {\r\n            width: colWidth,\r\n            height: innerHeight,\r\n            chartExtent: chartWidth,\r\n            //showGrid: this.props.showGrid,\r\n            isInnerAxis: rightColumnIndex === 0,\r\n            align: \"right\",\r\n            scale: this.scaleMap[id].latestScale()\r\n          };\r\n\r\n          // Cloned right axis\r\n          axis = React.cloneElement(yAxisMap[id], props);\r\n\r\n          axes.push(\r\n            <g key={`y-axis-right-${rightColumnIndex}`} transform={transform}>\r\n              {axis}\r\n            </g>\r\n          );\r\n        }\r\n      }\r\n\r\n      posx += colWidth;\r\n    }\r\n\r\n    //\r\n    // Push each chart onto the chartList, transforming each to the right\r\n    // of the left axis slots and specifying its width. Each chart is passed\r\n    // its time and y-scale. The y-scale is looked up in scaleMap, whose\r\n    // current value is stored in the component state.\r\n    //\r\n\r\n    const chartTransform = `translate(${leftWidth + paddingLeft},0)`;\r\n\r\n    let keyCount = 0;\r\n    React.Children.forEach(this.props.children, child => {\r\n      if (child === null) return;\r\n      if (areComponentsEqual(child.type, Charts)) {\r\n        const charts = child;\r\n        React.Children.forEach(charts.props.children, chart => {\r\n          if (!_.has(chart.props, \"visible\") || chart.props.visible) {\r\n            let scale = null;\r\n            if (_.has(this.state.yAxisScalerMap, chart.props.axis)) {\r\n              scale = this.state.yAxisScalerMap[chart.props.axis];\r\n            }\r\n\r\n            let ytransition = null;\r\n            if (_.has(this.scaleMap, chart.props.axis)) {\r\n              ytransition = this.scaleMap[chart.props.axis];\r\n            }\r\n\r\n            const chartProps = {\r\n              key: keyCount,\r\n              width: chartWidth,\r\n              height: innerHeight,\r\n              timeScale: this.props.timeScale,\r\n              timeFormat: this.props.timeFormat\r\n            };\r\n\r\n            if (scale) {\r\n              chartProps.yScale = scale;\r\n            }\r\n\r\n            if (ytransition) {\r\n              chartProps.transition = ytransition;\r\n            }\r\n\r\n            chartList.push(React.cloneElement(chart, chartProps));\r\n            keyCount += 1;\r\n          }\r\n        });\r\n      }\r\n    });\r\n\r\n    //\r\n    // Push each child Brush on to the brush list.  We need brushed to be\r\n    // rendered last (on top) of everything else in the Z order, both for\r\n    // visual correctness and to ensure that the brush gets mouse events\r\n    // before anything underneath\r\n    //\r\n\r\n    const brushList = [];\r\n    const multiBrushList = [];\r\n    keyCount = 0;\r\n    React.Children.forEach(this.props.children, child => {\r\n      if (child === null) return;\r\n      if (\r\n        areComponentsEqual(child.type, Brush) ||\r\n        areComponentsEqual(child.type, MultiBrush)\r\n      ) {\r\n        const brushProps = {\r\n          key: `brush-${keyCount}`,\r\n          width: chartWidth,\r\n          height: innerHeight,\r\n          timeScale: this.props.timeScale\r\n        };\r\n        if (areComponentsEqual(child.type, Brush)) {\r\n          brushList.push(React.cloneElement(child, brushProps));\r\n        } else {\r\n          multiBrushList.push(React.cloneElement(child, brushProps));\r\n        }\r\n      }\r\n      keyCount += 1;\r\n    });\r\n\r\n    const charts = (\r\n      <g transform={chartTransform} key=\"event-rect-group\">\r\n        <g key=\"charts\" clipPath={this.state.clipPathURL}>\r\n          {chartList}\r\n        </g>\r\n      </g>\r\n    );\r\n\r\n    //\r\n    // Clipping\r\n    //\r\n    const clipper = (\r\n      <defs>\r\n        <clipPath id={this.state.clipId}>\r\n          <rect\r\n            x=\"0\"\r\n            y=\"0\"\r\n            style={{ strokeOpacity: 0.0 }}\r\n            width={chartWidth}\r\n            height={innerHeight}\r\n          />\r\n        </clipPath>\r\n      </defs>\r\n    );\r\n\r\n    //\r\n    // Brush\r\n    //\r\n    const brushes = (\r\n      <g transform={chartTransform} key=\"brush-group\">\r\n        {brushList}\r\n      </g>\r\n    );\r\n\r\n    //\r\n    // Multi Brush\r\n    //\r\n    const multiBrushes = (\r\n      <g transform={chartTransform} key=\"multi-brush-group\">\r\n        {multiBrushList}\r\n      </g>\r\n    );\r\n\r\n    //\r\n    // TimeMarker used as a tracker\r\n    //\r\n    let tracker;\r\n    if (this.props.trackerTime) {\r\n      const timeFormat = this.props.trackerTimeFormat || this.props.timeFormat;\r\n      const timeMarkerProps = {\r\n        timeFormat,\r\n        showLine: false,\r\n        showTime: this.props.trackerShowTime,\r\n        time: this.props.trackerTime,\r\n        timeScale: this.props.timeScale,\r\n        width: chartWidth,\r\n        infoStyle: this.props.trackerStyle\r\n      };\r\n      if (this.props.trackerInfoValues) {\r\n        timeMarkerProps.infoWidth = this.props.trackerInfoWidth;\r\n        timeMarkerProps.infoHeight = this.props.trackerInfoHeight;\r\n        timeMarkerProps.infoValues = this.props.trackerInfoValues;\r\n        timeMarkerProps.timeFormat = this.props.trackerTimeFormat;\r\n      }\r\n      const trackerStyle = {\r\n        pointerEvents: \"none\"\r\n      };\r\n      const trackerTransform = `translate(${leftWidth + paddingLeft},0)`;\r\n\r\n      tracker = (\r\n        <g\r\n          key=\"tracker-group\"\r\n          style={trackerStyle}\r\n          transform={trackerTransform}\r\n        >\r\n          <TimeMarker {...timeMarkerProps} />\r\n        </g>\r\n      );\r\n    }\r\n\r\n    return (\r\n      <g>\r\n        {clipper}\r\n        {axes}\r\n        {charts}\r\n        {brushes}\r\n        {multiBrushes}\r\n        {tracker}\r\n      </g>\r\n    );\r\n  }\r\n}\r\n\r\nChartRow.defaultProps = {\r\n  trackerTimeFormat: \"%b %d %Y %X\",\r\n  enablePanZoom: false,\r\n  height: 100,\r\n  axisMargin: 5,\r\n  visible: true\r\n};\r\n\r\nChartRow.propTypes = {\r\n  /**\r\n   * The height of the row.\r\n   */\r\n  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\r\n\r\n  /**\r\n   * The vertical margin between the top and bottom of the row\r\n   * height and the top and bottom of the range of the chart.\r\n   */\r\n  axisMargin: PropTypes.number,\r\n\r\n  /**\r\n   * Show or hide this row\r\n   */\r\n  visible: PropTypes.bool,\r\n\r\n  /**\r\n   * Should the time be shown on top of the tracker info box\r\n   */\r\n  trackerShowTime: PropTypes.bool,\r\n\r\n  /**\r\n   * The width of the tracker info box\r\n   */\r\n  trackerInfoWidth: PropTypes.number,\r\n\r\n  /**\r\n   * The height of the tracker info box\r\n   */\r\n  trackerInfoHeight: PropTypes.number,\r\n\r\n  /**\r\n   * Info box value or values to place next to the tracker line.\r\n   * This is either an array of objects, with each object\r\n   * specifying the label (a string) and value (also a string)\r\n   * to be shown in the info box, or a simple string label.\r\n   */\r\n  trackerInfoValues: PropTypes.oneOfType([\r\n    PropTypes.string,\r\n    PropTypes.arrayOf(\r\n      PropTypes.shape({\r\n        label: PropTypes.string, // eslint-disable-line\r\n        value: PropTypes.string // eslint-disable-line\r\n      })\r\n    )\r\n  ]),\r\n\r\n  /**\r\n   * Specify the title for the chart row\r\n   */\r\n  title: PropTypes.string,\r\n\r\n  /**\r\n   * Specify the height of the title\r\n   * Default value is 28 pixels\r\n   */\r\n  titleHeight: PropTypes.number,\r\n\r\n  /**\r\n   * Specify the styling of the chart row's title\r\n   */\r\n  titleStyle: PropTypes.object,\r\n\r\n  /**\r\n   * Specify the styling of the box behind chart row's title\r\n   */\r\n  titleBoxStyle: PropTypes.object,\r\n\r\n  children: PropTypes.oneOfType([\r\n    PropTypes.arrayOf(PropTypes.node),\r\n    PropTypes.node\r\n  ]),\r\n  leftAxisWidths: PropTypes.arrayOf(PropTypes.number),\r\n  rightAxisWidths: PropTypes.arrayOf(PropTypes.number),\r\n  width: PropTypes.number,\r\n  timeScale: PropTypes.func,\r\n  trackerTimeFormat: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\r\n  timeFormat: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\r\n  trackerTime: PropTypes.instanceOf(Date)\r\n};\r\n"]},"metadata":{},"sourceType":"module"}