{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\golde\\\\resin\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nvar _jsxFileName = \"C:\\\\Users\\\\golde\\\\resin\\\\src\\\\Brush.js\";\n\n/**\r\n *  Copyright (c) 2016, The Regents of the University of California,\r\n *  through Lawrence Berkeley National Laboratory (subject to receipt\r\n *  of any required approvals from the U.S. Dept. of Energy).\r\n *  All rights reserved.\r\n *\r\n *  This source code is licensed under the BSD-style license found in the\r\n *  LICENSE file in the root directory of this source tree.\r\n */\nimport merge from \"merge\";\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { TimeRange } from \"pondjs\";\nimport getElementOffset from \"./utils/scaleAsString\";\n/**\r\n * Renders a brush with the range defined in the prop `timeRange`.\r\n */\n\nexport default class Brush extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      isBrushing: false\n    };\n    this.handleBrushMouseDown = this.handleBrushMouseDown.bind(this);\n    this.handleOverlayMouseDown = this.handleOverlayMouseDown.bind(this);\n    this.handleHandleMouseDown = this.handleHandleMouseDown.bind(this);\n    this.handleMouseUp = this.handleMouseUp.bind(this);\n    this.handleClick = this.handleClick.bind(this);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n  }\n\n  viewport() {\n    const _this$props = this.props,\n          width = _this$props.width,\n          timeScale = _this$props.timeScale;\n    const viewBeginTime = timeScale.invert(0);\n    const viewEndTime = timeScale.invert(width);\n    return new TimeRange(viewBeginTime, viewEndTime);\n  } //\n  // Event handlers\n  //\n\n\n  handleBrushMouseDown(e) {\n    e.preventDefault();\n    const x = e.pageX,\n          y = e.pageY;\n    const xy0 = [Math.round(x), Math.round(y)];\n    const begin = +this.props.timeRange.begin();\n    const end = +this.props.timeRange.end();\n    document.addEventListener(\"mouseup\", this.handleMouseUp);\n    this.setState({\n      isBrushing: true,\n      brushingInitializationSite: \"brush\",\n      initialBrushBeginTime: begin,\n      initialBrushEndTime: end,\n      initialBrushXYPosition: xy0\n    });\n  }\n\n  handleOverlayMouseDown(e) {\n    e.preventDefault();\n    const offset = getElementOffset(this.overlay);\n    const x = e.pageX - offset.left;\n    const t = this.props.timeScale.invert(x).getTime();\n    document.addEventListener(\"mouseup\", this.handleMouseUp);\n    this.setState({\n      isBrushing: true,\n      brushingInitializationSite: \"overlay\",\n      initialBrushBeginTime: t,\n      initialBrushEndTime: t,\n      initialBrushXYPosition: null\n    });\n  }\n\n  handleHandleMouseDown(e, handle) {\n    e.preventDefault();\n    const x = e.pageX,\n          y = e.pageY;\n    const xy0 = [Math.round(x), Math.round(y)];\n    const begin = this.props.timeRange.begin().getTime();\n    const end = this.props.timeRange.end().getTime();\n    document.addEventListener(\"mouseover\", this.handleMouseMove);\n    document.addEventListener(\"mouseup\", this.handleMouseUp);\n    this.setState({\n      isBrushing: true,\n      brushingInitializationSite: \"handle-\".concat(handle),\n      initialBrushBeginTime: begin,\n      initialBrushEndTime: end,\n      initialBrushXYPosition: xy0\n    });\n  }\n\n  handleMouseUp(e) {\n    e.preventDefault();\n    document.removeEventListener(\"mouseover\", this.handleMouseMove);\n    document.removeEventListener(\"mouseup\", this.handleMouseUp);\n    this.setState({\n      isBrushing: false,\n      brushingInitializationSite: null,\n      initialBrushBeginTime: null,\n      initialBrushEndTime: null,\n      initialBrushXYPosition: null\n    });\n  }\n  /**\r\n   * Handles clearing the TimeRange if the user clicks on the overlay (but\r\n   * doesn't drag to create a new brush). This will send a null as the\r\n   * new TimeRange. The user of this code can react to that however they\r\n   * see fit, but the most logical response is to reset the timerange to\r\n   * some initial value. This behavior is optional.\r\n   */\n\n\n  handleClick() {\n    if (this.props.allowSelectionClear && this.props.onTimeRangeChanged) {\n      this.props.onTimeRangeChanged(null);\n    }\n  }\n\n  handleMouseMove(e) {\n    e.preventDefault();\n    const x = e.pageX;\n    const y = e.pageY;\n    const xy = [Math.round(x), Math.round(y)];\n    const viewport = this.viewport();\n\n    if (this.state.isBrushing) {\n      let newBegin;\n      let newEnd;\n      const tb = this.state.initialBrushBeginTime;\n      const te = this.state.initialBrushEndTime;\n\n      if (this.state.brushingInitializationSite === \"overlay\") {\n        const offset = getElementOffset(this.overlay);\n        const xx = e.pageX - offset.left;\n        const t = this.props.timeScale.invert(xx).getTime();\n\n        if (t < tb) {\n          newBegin = t < viewport.begin().getTime() ? viewport.begin() : t;\n          newEnd = tb > viewport.end().getTime() ? viewport.end() : tb;\n        } else {\n          newBegin = tb < viewport.begin().getTime() ? viewport.begin() : tb;\n          newEnd = t > viewport.end().getTime() ? viewport.end() : t;\n        }\n      } else {\n        const xy0 = this.state.initialBrushXYPosition;\n        let timeOffset = this.props.timeScale.invert(xy0[0]).getTime() - this.props.timeScale.invert(xy[0]).getTime(); // Constrain\n\n        let startOffsetConstraint = timeOffset;\n        let endOffsetConstrain = timeOffset;\n\n        if (tb - timeOffset < viewport.begin()) {\n          startOffsetConstraint = tb - viewport.begin().getTime();\n        }\n\n        if (te - timeOffset > viewport.end()) {\n          endOffsetConstrain = te - viewport.end().getTime();\n        }\n\n        newBegin = this.state.brushingInitializationSite === \"brush\" || this.state.brushingInitializationSite === \"handle-left\" ? parseInt(tb - startOffsetConstraint, 10) : tb;\n        newEnd = this.state.brushingInitializationSite === \"brush\" || this.state.brushingInitializationSite === \"handle-right\" ? parseInt(te - endOffsetConstrain, 10) : te; // Swap if needed\n\n        if (newBegin > newEnd) {\n          var _ref = [newEnd, newBegin];\n          newBegin = _ref[0];\n          newEnd = _ref[1];\n        }\n      }\n\n      if (this.props.onTimeRangeChanged) {\n        this.props.onTimeRangeChanged(new TimeRange(newBegin, newEnd));\n      }\n    }\n  } //\n  // Render\n  //\n\n\n  renderOverlay() {\n    const _this$props2 = this.props,\n          width = _this$props2.width,\n          height = _this$props2.height;\n    let cursor;\n\n    switch (this.state.brushingInitializationSite) {\n      case \"handle-right\":\n      case \"handle-left\":\n        cursor = \"ew-resize\";\n        break;\n\n      case \"brush\":\n        cursor = \"move\";\n        break;\n\n      default:\n        cursor = \"crosshair\";\n    }\n\n    const overlayStyle = {\n      fill: \"white\",\n      opacity: 0,\n      cursor\n    };\n    return React.createElement(\"rect\", {\n      ref: c => {\n        this.overlay = c;\n      },\n      x: 0,\n      y: 0,\n      width: width,\n      height: height,\n      style: overlayStyle,\n      onMouseDown: this.handleOverlayMouseDown,\n      onMouseUp: this.handleMouseUp,\n      onClick: this.handleClick,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 221\n      },\n      __self: this\n    });\n  }\n\n  renderBrush() {\n    const _this$props3 = this.props,\n          timeRange = _this$props3.timeRange,\n          timeScale = _this$props3.timeScale,\n          height = _this$props3.height,\n          style = _this$props3.style;\n\n    if (!timeRange) {\n      return React.createElement(\"g\", {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 241\n        },\n        __self: this\n      });\n    }\n\n    let cursor;\n\n    switch (this.state.brushingInitializationSite) {\n      case \"handle-right\":\n      case \"handle-left\":\n        cursor = \"ew-resize\";\n        break;\n\n      case \"overlay\":\n        cursor = \"crosshair\";\n        break;\n\n      default:\n        cursor = \"move\";\n    } // Style of the brush area\n\n\n    const brushDefaultStyle = {\n      fill: \"#777\",\n      fillOpacity: 0.3,\n      stroke: \"#fff\",\n      shapeRendering: \"crispEdges\",\n      cursor\n    };\n    const brushStyle = merge(true, brushDefaultStyle, style);\n\n    if (!this.viewport().disjoint(timeRange)) {\n      const range = timeRange.intersection(this.viewport());\n      const begin = range.begin();\n      const end = range.end();\n      const _ref2 = [timeScale(begin), 0],\n            x = _ref2[0],\n            y = _ref2[1];\n      const endPos = timeScale(end);\n      let width = endPos - x;\n\n      if (width < 1) {\n        width = 1;\n      }\n\n      const bounds = {\n        x,\n        y,\n        width,\n        height\n      };\n      return React.createElement(\"rect\", Object.assign({}, bounds, {\n        style: brushStyle,\n        pointerEvents: \"all\",\n        onMouseDown: this.handleBrushMouseDown,\n        onMouseUp: this.handleMouseUp,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 281\n        },\n        __self: this\n      }));\n    }\n\n    return React.createElement(\"g\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 290\n      },\n      __self: this\n    });\n  }\n\n  renderHandles() {\n    const _this$props4 = this.props,\n          timeRange = _this$props4.timeRange,\n          timeScale = _this$props4.timeScale,\n          height = _this$props4.height;\n\n    if (!timeRange) {\n      return React.createElement(\"g\", {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 297\n        },\n        __self: this\n      });\n    } // Style of the handles\n\n\n    const handleStyle = {\n      fill: \"white\",\n      opacity: 0,\n      cursor: \"ew-resize\"\n    };\n\n    if (!this.viewport().disjoint(timeRange)) {\n      const range = timeRange.intersection(this.viewport());\n\n      const _range$toJSON = range.toJSON(),\n            _range$toJSON2 = _slicedToArray(_range$toJSON, 2),\n            begin = _range$toJSON2[0],\n            end = _range$toJSON2[1];\n\n      const _ref3 = [timeScale(begin), 0],\n            x = _ref3[0],\n            y = _ref3[1];\n      const endPos = timeScale(end);\n      let width = endPos - x;\n\n      if (width < 1) {\n        width = 1;\n      }\n\n      const handleSize = this.props.handleSize;\n      const leftHandleBounds = {\n        x: x - 1,\n        y,\n        width: handleSize,\n        height\n      };\n      const rightHandleBounds = {\n        x: x + (width - handleSize),\n        y,\n        width: handleSize + 1,\n        height\n      };\n      return React.createElement(\"g\", {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 329\n        },\n        __self: this\n      }, React.createElement(\"rect\", Object.assign({}, leftHandleBounds, {\n        style: handleStyle,\n        pointerEvents: \"all\",\n        onMouseDown: e => this.handleHandleMouseDown(e, \"left\"),\n        onMouseUp: this.handleMouseUp,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 330\n        },\n        __self: this\n      })), React.createElement(\"rect\", Object.assign({}, rightHandleBounds, {\n        style: handleStyle,\n        pointerEvents: \"all\",\n        onMouseDown: e => this.handleHandleMouseDown(e, \"right\"),\n        onMouseUp: this.handleMouseUp,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 337\n        },\n        __self: this\n      })));\n    }\n\n    return React.createElement(\"g\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 347\n      },\n      __self: this\n    });\n  }\n\n  render() {\n    return React.createElement(\"g\", {\n      onMouseMove: this.handleMouseMove,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 352\n      },\n      __self: this\n    }, this.renderOverlay(), this.renderBrush(), this.renderHandles());\n  }\n\n}\nBrush.propTypes = {\n  /**\r\n   * The timerange for the brush. Typically you would maintain this\r\n   * as state on the surrounding page, since it would likely control\r\n   * another page element, such as the range of the main chart. See\r\n   * also `onTimeRangeChanged()` for receiving notification of the\r\n   * brush range being changed by the user.\r\n   *\r\n   * Takes a Pond TimeRange object.\r\n   */\n  timeRange: PropTypes.instanceOf(TimeRange),\n\n  /**\r\n   * The brush is rendered as an SVG rect. You can specify the style\r\n   * of this rect using this prop.\r\n   */\n  style: PropTypes.object,\n  //eslint-disable-line\n\n  /**\r\n   * The size of the invisible side handles. Defaults to 6 pixels.\r\n   */\n  handleSize: PropTypes.number,\n  allowSelectionClear: PropTypes.bool,\n\n  /**\r\n   * A callback which will be called if the brush range is changed by\r\n   * the user. It is called with a Pond TimeRange object. Note that if\r\n   * `allowSelectionClear` is set to true, then this can also be called\r\n   * when the user performs a simple click outside the brush area. In\r\n   * this case it will be called with null as the TimeRange. You can\r\n   * use this to reset the selection, perhaps to some initial range.\r\n   */\n  onTimeRangeChanged: PropTypes.func,\n\n  /**\r\n   * [Internal] The timeScale supplied by the surrounding ChartContainer\r\n   */\n  timeScale: PropTypes.func,\n\n  /**\r\n   * [Internal] The width supplied by the surrounding ChartContainer\r\n   */\n  width: PropTypes.number,\n\n  /**\r\n   * [Internal] The height supplied by the surrounding ChartContainer\r\n   */\n  height: PropTypes.number\n};\nBrush.defaultProps = {\n  handleSize: 6,\n  allowSelectionClear: false\n};","map":{"version":3,"sources":["C:\\Users\\golde\\resin\\src\\Brush.js"],"names":["merge","React","PropTypes","TimeRange","getElementOffset","Brush","Component","constructor","props","state","isBrushing","handleBrushMouseDown","bind","handleOverlayMouseDown","handleHandleMouseDown","handleMouseUp","handleClick","handleMouseMove","viewport","width","timeScale","viewBeginTime","invert","viewEndTime","e","preventDefault","x","pageX","y","pageY","xy0","Math","round","begin","timeRange","end","document","addEventListener","setState","brushingInitializationSite","initialBrushBeginTime","initialBrushEndTime","initialBrushXYPosition","offset","overlay","left","t","getTime","handle","removeEventListener","allowSelectionClear","onTimeRangeChanged","xy","newBegin","newEnd","tb","te","xx","timeOffset","startOffsetConstraint","endOffsetConstrain","parseInt","renderOverlay","height","cursor","overlayStyle","fill","opacity","c","renderBrush","style","brushDefaultStyle","fillOpacity","stroke","shapeRendering","brushStyle","disjoint","range","intersection","endPos","bounds","renderHandles","handleStyle","toJSON","handleSize","leftHandleBounds","rightHandleBounds","render","propTypes","instanceOf","object","number","bool","func","defaultProps"],"mappings":"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","sourcesContent":["/**\r\n *  Copyright (c) 2016, The Regents of the University of California,\r\n *  through Lawrence Berkeley National Laboratory (subject to receipt\r\n *  of any required approvals from the U.S. Dept. of Energy).\r\n *  All rights reserved.\r\n *\r\n *  This source code is licensed under the BSD-style license found in the\r\n *  LICENSE file in the root directory of this source tree.\r\n */\r\n\r\nimport merge from \"merge\";\r\nimport React from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport { TimeRange } from \"pondjs\";\r\nimport getElementOffset from \"./utils/scaleAsString\";\r\n\r\n/**\r\n * Renders a brush with the range defined in the prop `timeRange`.\r\n */\r\nexport default class Brush extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      isBrushing: false\r\n    };\r\n\r\n    this.handleBrushMouseDown = this.handleBrushMouseDown.bind(this);\r\n    this.handleOverlayMouseDown = this.handleOverlayMouseDown.bind(this);\r\n    this.handleHandleMouseDown = this.handleHandleMouseDown.bind(this);\r\n    this.handleMouseUp = this.handleMouseUp.bind(this);\r\n    this.handleClick = this.handleClick.bind(this);\r\n    this.handleMouseMove = this.handleMouseMove.bind(this);\r\n  }\r\n\r\n  viewport() {\r\n    const { width, timeScale } = this.props;\r\n    const viewBeginTime = timeScale.invert(0);\r\n    const viewEndTime = timeScale.invert(width);\r\n    return new TimeRange(viewBeginTime, viewEndTime);\r\n  }\r\n\r\n  //\r\n  // Event handlers\r\n  //\r\n\r\n  handleBrushMouseDown(e) {\r\n    e.preventDefault();\r\n\r\n    const { pageX: x, pageY: y } = e;\r\n    const xy0 = [Math.round(x), Math.round(y)];\r\n    const begin = +this.props.timeRange.begin();\r\n    const end = +this.props.timeRange.end();\r\n\r\n    document.addEventListener(\"mouseup\", this.handleMouseUp);\r\n\r\n    this.setState({\r\n      isBrushing: true,\r\n      brushingInitializationSite: \"brush\",\r\n      initialBrushBeginTime: begin,\r\n      initialBrushEndTime: end,\r\n      initialBrushXYPosition: xy0\r\n    });\r\n  }\r\n\r\n  handleOverlayMouseDown(e) {\r\n    e.preventDefault();\r\n\r\n    const offset = getElementOffset(this.overlay);\r\n    const x = e.pageX - offset.left;\r\n    const t = this.props.timeScale.invert(x).getTime();\r\n\r\n    document.addEventListener(\"mouseup\", this.handleMouseUp);\r\n\r\n    this.setState({\r\n      isBrushing: true,\r\n      brushingInitializationSite: \"overlay\",\r\n      initialBrushBeginTime: t,\r\n      initialBrushEndTime: t,\r\n      initialBrushXYPosition: null\r\n    });\r\n  }\r\n\r\n  handleHandleMouseDown(e, handle) {\r\n    e.preventDefault();\r\n\r\n    const { pageX: x, pageY: y } = e;\r\n    const xy0 = [Math.round(x), Math.round(y)];\r\n    const begin = this.props.timeRange.begin().getTime();\r\n    const end = this.props.timeRange.end().getTime();\r\n\r\n    document.addEventListener(\"mouseover\", this.handleMouseMove);\r\n    document.addEventListener(\"mouseup\", this.handleMouseUp);\r\n\r\n    this.setState({\r\n      isBrushing: true,\r\n      brushingInitializationSite: `handle-${handle}`,\r\n      initialBrushBeginTime: begin,\r\n      initialBrushEndTime: end,\r\n      initialBrushXYPosition: xy0\r\n    });\r\n  }\r\n\r\n  handleMouseUp(e) {\r\n    e.preventDefault();\r\n\r\n    document.removeEventListener(\"mouseover\", this.handleMouseMove);\r\n    document.removeEventListener(\"mouseup\", this.handleMouseUp);\r\n\r\n    this.setState({\r\n      isBrushing: false,\r\n      brushingInitializationSite: null,\r\n      initialBrushBeginTime: null,\r\n      initialBrushEndTime: null,\r\n      initialBrushXYPosition: null\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handles clearing the TimeRange if the user clicks on the overlay (but\r\n   * doesn't drag to create a new brush). This will send a null as the\r\n   * new TimeRange. The user of this code can react to that however they\r\n   * see fit, but the most logical response is to reset the timerange to\r\n   * some initial value. This behavior is optional.\r\n   */\r\n  handleClick() {\r\n    if (this.props.allowSelectionClear && this.props.onTimeRangeChanged) {\r\n      this.props.onTimeRangeChanged(null);\r\n    }\r\n  }\r\n\r\n  handleMouseMove(e) {\r\n    e.preventDefault();\r\n\r\n    const x = e.pageX;\r\n    const y = e.pageY;\r\n    const xy = [Math.round(x), Math.round(y)];\r\n    const viewport = this.viewport();\r\n\r\n    if (this.state.isBrushing) {\r\n      let newBegin;\r\n      let newEnd;\r\n\r\n      const tb = this.state.initialBrushBeginTime;\r\n      const te = this.state.initialBrushEndTime;\r\n\r\n      if (this.state.brushingInitializationSite === \"overlay\") {\r\n        const offset = getElementOffset(this.overlay);\r\n        const xx = e.pageX - offset.left;\r\n        const t = this.props.timeScale.invert(xx).getTime();\r\n        if (t < tb) {\r\n          newBegin = t < viewport.begin().getTime() ? viewport.begin() : t;\r\n          newEnd = tb > viewport.end().getTime() ? viewport.end() : tb;\r\n        } else {\r\n          newBegin = tb < viewport.begin().getTime() ? viewport.begin() : tb;\r\n          newEnd = t > viewport.end().getTime() ? viewport.end() : t;\r\n        }\r\n      } else {\r\n        const xy0 = this.state.initialBrushXYPosition;\r\n        let timeOffset =\r\n          this.props.timeScale.invert(xy0[0]).getTime() -\r\n          this.props.timeScale.invert(xy[0]).getTime();\r\n\r\n        // Constrain\r\n        let startOffsetConstraint = timeOffset;\r\n        let endOffsetConstrain = timeOffset;\r\n        if (tb - timeOffset < viewport.begin()) {\r\n          startOffsetConstraint = tb - viewport.begin().getTime();\r\n        }\r\n        if (te - timeOffset > viewport.end()) {\r\n          endOffsetConstrain = te - viewport.end().getTime();\r\n        }\r\n\r\n        newBegin =\r\n          this.state.brushingInitializationSite === \"brush\" ||\r\n          this.state.brushingInitializationSite === \"handle-left\"\r\n            ? parseInt(tb - startOffsetConstraint, 10)\r\n            : tb;\r\n        newEnd =\r\n          this.state.brushingInitializationSite === \"brush\" ||\r\n          this.state.brushingInitializationSite === \"handle-right\"\r\n            ? parseInt(te - endOffsetConstrain, 10)\r\n            : te;\r\n\r\n        // Swap if needed\r\n        if (newBegin > newEnd) [newBegin, newEnd] = [newEnd, newBegin];\r\n      }\r\n\r\n      if (this.props.onTimeRangeChanged) {\r\n        this.props.onTimeRangeChanged(new TimeRange(newBegin, newEnd));\r\n      }\r\n    }\r\n  }\r\n\r\n  //\r\n  // Render\r\n  //\r\n\r\n  renderOverlay() {\r\n    const { width, height } = this.props;\r\n\r\n    let cursor;\r\n    switch (this.state.brushingInitializationSite) {\r\n      case \"handle-right\":\r\n      case \"handle-left\":\r\n        cursor = \"ew-resize\";\r\n        break;\r\n      case \"brush\":\r\n        cursor = \"move\";\r\n        break;\r\n      default:\r\n        cursor = \"crosshair\";\r\n    }\r\n\r\n    const overlayStyle = {\r\n      fill: \"white\",\r\n      opacity: 0,\r\n      cursor\r\n    };\r\n    return (\r\n      <rect\r\n        ref={c => {\r\n          this.overlay = c;\r\n        }}\r\n        x={0}\r\n        y={0}\r\n        width={width}\r\n        height={height}\r\n        style={overlayStyle}\r\n        onMouseDown={this.handleOverlayMouseDown}\r\n        onMouseUp={this.handleMouseUp}\r\n        onClick={this.handleClick}\r\n      />\r\n    );\r\n  }\r\n\r\n  renderBrush() {\r\n    const { timeRange, timeScale, height, style } = this.props;\r\n\r\n    if (!timeRange) {\r\n      return <g />;\r\n    }\r\n\r\n    let cursor;\r\n    switch (this.state.brushingInitializationSite) {\r\n      case \"handle-right\":\r\n      case \"handle-left\":\r\n        cursor = \"ew-resize\";\r\n        break;\r\n      case \"overlay\":\r\n        cursor = \"crosshair\";\r\n        break;\r\n      default:\r\n        cursor = \"move\";\r\n    }\r\n\r\n    // Style of the brush area\r\n    const brushDefaultStyle = {\r\n      fill: \"#777\",\r\n      fillOpacity: 0.3,\r\n      stroke: \"#fff\",\r\n      shapeRendering: \"crispEdges\",\r\n      cursor\r\n    };\r\n    const brushStyle = merge(true, brushDefaultStyle, style);\r\n\r\n    if (!this.viewport().disjoint(timeRange)) {\r\n      const range = timeRange.intersection(this.viewport());\r\n      const begin = range.begin();\r\n      const end = range.end();\r\n      const [x, y] = [timeScale(begin), 0];\r\n      const endPos = timeScale(end);\r\n      let width = endPos - x;\r\n      if (width < 1) {\r\n        width = 1;\r\n      }\r\n\r\n      const bounds = { x, y, width, height };\r\n\r\n      return (\r\n        <rect\r\n          {...bounds}\r\n          style={brushStyle}\r\n          pointerEvents=\"all\"\r\n          onMouseDown={this.handleBrushMouseDown}\r\n          onMouseUp={this.handleMouseUp}\r\n        />\r\n      );\r\n    }\r\n    return <g />;\r\n  }\r\n\r\n  renderHandles() {\r\n    const { timeRange, timeScale, height } = this.props;\r\n\r\n    if (!timeRange) {\r\n      return <g />;\r\n    }\r\n\r\n    // Style of the handles\r\n    const handleStyle = {\r\n      fill: \"white\",\r\n      opacity: 0,\r\n      cursor: \"ew-resize\"\r\n    };\r\n\r\n    if (!this.viewport().disjoint(timeRange)) {\r\n      const range = timeRange.intersection(this.viewport());\r\n      const [begin, end] = range.toJSON();\r\n      const [x, y] = [timeScale(begin), 0];\r\n      const endPos = timeScale(end);\r\n\r\n      let width = endPos - x;\r\n      if (width < 1) {\r\n        width = 1;\r\n      }\r\n\r\n      const handleSize = this.props.handleSize;\r\n\r\n      const leftHandleBounds = { x: x - 1, y, width: handleSize, height };\r\n      const rightHandleBounds = {\r\n        x: x + (width - handleSize),\r\n        y,\r\n        width: handleSize + 1,\r\n        height\r\n      };\r\n\r\n      return (\r\n        <g>\r\n          <rect\r\n            {...leftHandleBounds}\r\n            style={handleStyle}\r\n            pointerEvents=\"all\"\r\n            onMouseDown={e => this.handleHandleMouseDown(e, \"left\")}\r\n            onMouseUp={this.handleMouseUp}\r\n          />\r\n          <rect\r\n            {...rightHandleBounds}\r\n            style={handleStyle}\r\n            pointerEvents=\"all\"\r\n            onMouseDown={e => this.handleHandleMouseDown(e, \"right\")}\r\n            onMouseUp={this.handleMouseUp}\r\n          />\r\n        </g>\r\n      );\r\n    }\r\n    return <g />;\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <g onMouseMove={this.handleMouseMove}>\r\n        {this.renderOverlay()}\r\n        {this.renderBrush()}\r\n        {this.renderHandles()}\r\n      </g>\r\n    );\r\n  }\r\n}\r\n\r\nBrush.propTypes = {\r\n  /**\r\n   * The timerange for the brush. Typically you would maintain this\r\n   * as state on the surrounding page, since it would likely control\r\n   * another page element, such as the range of the main chart. See\r\n   * also `onTimeRangeChanged()` for receiving notification of the\r\n   * brush range being changed by the user.\r\n   *\r\n   * Takes a Pond TimeRange object.\r\n   */\r\n  timeRange: PropTypes.instanceOf(TimeRange),\r\n  /**\r\n   * The brush is rendered as an SVG rect. You can specify the style\r\n   * of this rect using this prop.\r\n   */\r\n  style: PropTypes.object, //eslint-disable-line\r\n  /**\r\n   * The size of the invisible side handles. Defaults to 6 pixels.\r\n   */\r\n  handleSize: PropTypes.number,\r\n  allowSelectionClear: PropTypes.bool,\r\n  /**\r\n   * A callback which will be called if the brush range is changed by\r\n   * the user. It is called with a Pond TimeRange object. Note that if\r\n   * `allowSelectionClear` is set to true, then this can also be called\r\n   * when the user performs a simple click outside the brush area. In\r\n   * this case it will be called with null as the TimeRange. You can\r\n   * use this to reset the selection, perhaps to some initial range.\r\n   */\r\n  onTimeRangeChanged: PropTypes.func,\r\n  /**\r\n   * [Internal] The timeScale supplied by the surrounding ChartContainer\r\n   */\r\n  timeScale: PropTypes.func,\r\n  /**\r\n   * [Internal] The width supplied by the surrounding ChartContainer\r\n   */\r\n  width: PropTypes.number,\r\n  /**\r\n   * [Internal] The height supplied by the surrounding ChartContainer\r\n   */\r\n  height: PropTypes.number\r\n};\r\n\r\nBrush.defaultProps = {\r\n  handleSize: 6,\r\n  allowSelectionClear: false\r\n};\r\n"]},"metadata":{},"sourceType":"module"}