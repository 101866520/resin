{"ast":null,"code":"import _taggedTemplateLiteral from \"C:\\\\Users\\\\golde\\\\resin\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/taggedTemplateLiteral\";\nvar _jsxFileName = \"C:\\\\Users\\\\golde\\\\resin\\\\src\\\\Timeline.js\";\n\nfunction _templateObject() {\n  const data = _taggedTemplateLiteral([\"\\n  overflow: hidden;\\n  width: 100%;\\n  background-color: #222;\\n  position: relative;\\n  margin: 0.25rem;\\n  box-shadow: 0.1rem 0.1rem 0.05rem rgba(0, 0, 0, 0.3);\\n  border-radius: 0.2rem;\\n\"]);\n\n  _templateObject = function () {\n    return data;\n  };\n\n  return data;\n}\n\nimport React from \"react\";\nimport \"moment-duration-format\";\nimport moment from \"moment\";\nimport { TimeSeries, TimeRange, avg } from \"pondjs\";\nimport ChartContainer from \"./ChartContainer\";\nimport ChartRow from \"./ChartRow\";\nimport Charts from \"./Charts\";\nimport YAxis from \"./YAxis\";\nimport LineChart from \"./LineChart\";\nimport Resizable from \"./Resizable\";\nimport ValueAxis from \"./ValueAxis\";\nimport data from \"./bike.json\";\nimport styled from \"styled-components\";\nimport styler from \"./utils/styler\";\nimport { islandCss } from \"./Dashboard\";\nconst Wrapper = styled.div(_templateObject());\nconst style = styler([{\n  key: \"altitude\",\n  color: \"magenta\",\n  width: 2\n}, {\n  key: \"cadence\",\n  color: \"yellow\",\n  width: 2\n}, {\n  key: \"power\",\n  color: \"lime\",\n  width: 2\n}, {\n  key: \"moving\",\n  color: \"red\",\n  width: 2\n}]);\nconst channels = {\n  altitude: {\n    units: \"feet\",\n    label: \"Altitude\",\n    format: \"d\",\n    series: null,\n    chartType: \"line\"\n  },\n  cadence: {\n    units: \"rpm\",\n    label: \"Cadence\",\n    format: \"d\",\n    series: null,\n    chartType: \"line\"\n  },\n  // moving: {\n  //   units: \"watts\",\n  //   label: \"Moving\",\n  //   format: \",.1f\",\n  //   series: null,\n  //   chartType: \"boolean\"\n  // },\n  power: {\n    units: \"watts\",\n    label: \"Power\",\n    format: \",.1f\",\n    series: null,\n    chartType: \"line\"\n  }\n};\n\nconst fibbonacci = max => {\n  var result = [1, 2];\n\n  while (result[result.length - 1] < max) {\n    result.push(result[result.length - 1] + result[result.length - 2]);\n  }\n\n  return result;\n};\n\nconst rollupLevels = fibbonacci(200);\nexport default class Timeline extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.handleTrackerChanged = tracker => this.setState({\n      tracker\n    });\n\n    this.handleTimeRangeChange = timerange => this.setState({\n      timerange: timerange || this.state.channels[\"altitude\"].range()\n    });\n\n    this.handleChartResize = width => this.setState({\n      width\n    });\n\n    this.handleActiveChange = channelName => {\n      const channels = this.state.channels;\n      channels[channelName].show = !channels[channelName].show;\n      this.setState({\n        channels\n      });\n    };\n\n    this.renderChannelsChart = () => {\n      const _this$state = this.state,\n            timerange = _this$state.timerange,\n            channels = _this$state.channels,\n            maxTime = _this$state.maxTime,\n            minTime = _this$state.minTime;\n      const durationPerPixel = timerange.duration() / 800 / 1000;\n      const rows = [];\n      Object.keys(channels).forEach(channelName => {\n        const channel = channels[channelName];\n        const charts = [];\n        let series = channel.series;\n        channel.rollups.forEach(rollup => {\n          if (rollup.duration < durationPerPixel * 2) {\n            series = rollup.series.crop(new TimeRange([timerange.begin() - timerange.duration() / 2, timerange.end() + timerange.duration() / 2]));\n          }\n        });\n        if (channel.chartType === \"line\") charts.push(React.createElement(LineChart, {\n          key: \"line-\".concat(channelName),\n          axis: \"\".concat(channelName, \"_axis\"),\n          series: series,\n          columns: [channelName],\n          breakLine: true,\n          style: style,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 172\n          },\n          __self: this\n        }));else if (channel.chartType === \"boolean\") charts.push();\n        let value = \"--\";\n\n        if (this.state.tracker) {\n          const approx = (+this.state.tracker - +timerange.begin()) / (+timerange.end() - +timerange.begin());\n          const ii = Math.floor(approx * series.size());\n          const i = series.bisect(new Date(this.state.tracker), ii);\n          const v = i < series.size() ? series.at(i).get(channelName) : null;\n\n          if (v) {\n            value = parseInt(v, 10);\n          }\n        }\n\n        rows.push(React.createElement(ChartRow, {\n          height: \"80\",\n          key: \"row-\".concat(channelName),\n          title: channelName,\n          titleStyle: {\n            color: \"#fff\",\n            backgroundColor: \"#222\"\n          },\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 197\n          },\n          __self: this\n        }, React.createElement(YAxis, {\n          id: \"\".concat(channelName, \"_axis\"),\n          visible: false,\n          min: channel.min,\n          max: channel.max,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 203\n          },\n          __self: this\n        }), React.createElement(Charts, {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 209\n          },\n          __self: this\n        }, charts), React.createElement(ValueAxis, {\n          id: \"\".concat(channelName, \"_valueaxis\"),\n          value: value,\n          detail: channels[channelName].units,\n          width: 60,\n          min: 0,\n          max: 35,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 210\n          },\n          __self: this\n        })));\n      });\n      return React.createElement(ChartContainer, {\n        timeRange: this.state.timerange,\n        format: \"relative\",\n        showGrid: false,\n        trackerShowTime: false,\n        enablePanZoom: true,\n        minDuration: 1000,\n        maxTime: maxTime,\n        minTime: minTime,\n        trackerPosition: this.state.tracker,\n        onTimeRangeChanged: this.handleTimeRangeChange,\n        onChartResize: width => this.handleChartResize(width),\n        onTrackerChanged: this.handleTrackerChanged,\n        hideTimeAxis: true,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 223\n        },\n        __self: this\n      }, rows);\n    };\n\n    this.render = () => React.createElement(Wrapper, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 244\n      },\n      __self: this\n    }, this.state.ready ? React.createElement(React.Fragment, null, React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 247\n      },\n      __self: this\n    }, React.createElement(Resizable, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 248\n      },\n      __self: this\n    }, this.renderChannelsChart())), React.createElement(\"div\", {\n      style: {\n        borderTop: \"0.2rem solid #aaa\",\n        backgroundColor: \"#ccc\",\n        color: \"fff\",\n        position: \"absolute\",\n        bottom: 0,\n        left: 0,\n        right: 0\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 250\n      },\n      __self: this\n    }, this.state.tracker ? \"\".concat(moment.duration(+this.state.tracker).format()) : \"-:--:--\"), \" \") : React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 267\n      },\n      __self: this\n    }, \"...\"));\n\n    const initialRange = new TimeRange([75 * 60 * 1000, 125 * 60 * 1000]);\n    this.state = {\n      ready: false,\n      channels,\n      rollup: \"1m\",\n      tracker: null,\n      timerange: initialRange\n    };\n  }\n\n  componentDidMount() {\n    setTimeout(() => {\n      const channels = this.state.channels;\n      const points = {};\n      Object.keys(channels).forEach(channelName => {\n        points[channelName] = [];\n      });\n\n      for (let i = 1; i < data.time.length; i += 1) {\n        const time = data.time[i] * 1000;\n        Object.keys(channels).forEach(channelName => {\n          points[channelName].push([time, data[channelName][i]]);\n        });\n      }\n\n      Object.keys(channels).forEach(channelName => {\n        const channel = channels[channelName];\n        const series = new TimeSeries({\n          name: channel.name,\n          columns: [\"time\", channelName],\n          points: points[channelName]\n        });\n        channel.series = series;\n        channel.rollups = rollupLevels.map(rollupLevel => ({\n          duration: rollupLevel,\n          series: series.fixedWindowRollup({\n            windowSize: rollupLevel + \"s\",\n            aggregation: {\n              [channelName]: {\n                [channelName]: avg()\n              }\n            }\n          })\n        }));\n        channel.avg = parseInt(series.avg(channelName), 10);\n        channel.min = parseInt(series.min(channelName), 10);\n        channel.max = parseInt(series.max(channelName), 10);\n      });\n      const minTime = channels.altitude.series.range().begin();\n      const maxTime = channels.altitude.series.range().end();\n      this.setState({\n        ready: true,\n        channels,\n        minTime,\n        maxTime\n      });\n    }, 0);\n  }\n\n}","map":{"version":3,"sources":["C:\\Users\\golde\\resin\\src\\Timeline.js"],"names":["React","moment","TimeSeries","TimeRange","avg","ChartContainer","ChartRow","Charts","YAxis","LineChart","Resizable","ValueAxis","data","styled","styler","islandCss","Wrapper","div","style","key","color","width","channels","altitude","units","label","format","series","chartType","cadence","power","fibbonacci","max","result","length","push","rollupLevels","Timeline","Component","constructor","props","handleTrackerChanged","tracker","setState","handleTimeRangeChange","timerange","state","range","handleChartResize","handleActiveChange","channelName","show","renderChannelsChart","maxTime","minTime","durationPerPixel","duration","rows","Object","keys","forEach","channel","charts","rollups","rollup","crop","begin","end","value","approx","ii","Math","floor","size","i","bisect","Date","v","at","get","parseInt","backgroundColor","min","render","ready","borderTop","position","bottom","left","right","initialRange","componentDidMount","setTimeout","points","time","name","columns","map","rollupLevel","fixedWindowRollup","windowSize","aggregation"],"mappings":";;;;;;;;;;;;;AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAO,wBAAP;AACA,OAAOC,MAAP,MAAmB,QAAnB;AACA,SAASC,UAAT,EAAqBC,SAArB,EAAgCC,GAAhC,QAA2C,QAA3C;AACA,OAAOC,cAAP,MAA2B,kBAA3B;AACA,OAAOC,QAAP,MAAqB,YAArB;AACA,OAAOC,MAAP,MAAmB,UAAnB;AACA,OAAOC,KAAP,MAAkB,SAAlB;AACA,OAAOC,SAAP,MAAsB,aAAtB;AACA,OAAOC,SAAP,MAAsB,aAAtB;AACA,OAAOC,SAAP,MAAsB,aAAtB;AACA,OAAOC,IAAP,MAAiB,aAAjB;AACA,OAAOC,MAAP,MAAmB,mBAAnB;AACA,OAAOC,MAAP,MAAmB,gBAAnB;AACA,SAASC,SAAT,QAA0B,aAA1B;AAEA,MAAMC,OAAO,GAAGH,MAAM,CAACI,GAAV,mBAAb;AAUA,MAAMC,KAAK,GAAGJ,MAAM,CAAC,CACnB;AAAEK,EAAAA,GAAG,EAAE,UAAP;AAAmBC,EAAAA,KAAK,EAAE,SAA1B;AAAqCC,EAAAA,KAAK,EAAE;AAA5C,CADmB,EAEnB;AAAEF,EAAAA,GAAG,EAAE,SAAP;AAAkBC,EAAAA,KAAK,EAAE,QAAzB;AAAmCC,EAAAA,KAAK,EAAE;AAA1C,CAFmB,EAGnB;AAAEF,EAAAA,GAAG,EAAE,OAAP;AAAgBC,EAAAA,KAAK,EAAE,MAAvB;AAA+BC,EAAAA,KAAK,EAAE;AAAtC,CAHmB,EAInB;AAAEF,EAAAA,GAAG,EAAE,QAAP;AAAiBC,EAAAA,KAAK,EAAE,KAAxB;AAA+BC,EAAAA,KAAK,EAAE;AAAtC,CAJmB,CAAD,CAApB;AAOA,MAAMC,QAAQ,GAAG;AACfC,EAAAA,QAAQ,EAAE;AACRC,IAAAA,KAAK,EAAE,MADC;AAERC,IAAAA,KAAK,EAAE,UAFC;AAGRC,IAAAA,MAAM,EAAE,GAHA;AAIRC,IAAAA,MAAM,EAAE,IAJA;AAKRC,IAAAA,SAAS,EAAE;AALH,GADK;AAQfC,EAAAA,OAAO,EAAE;AACPL,IAAAA,KAAK,EAAE,KADA;AAEPC,IAAAA,KAAK,EAAE,SAFA;AAGPC,IAAAA,MAAM,EAAE,GAHD;AAIPC,IAAAA,MAAM,EAAE,IAJD;AAKPC,IAAAA,SAAS,EAAE;AALJ,GARM;AAef;AACA;AACA;AACA;AACA;AACA;AACA;AACAE,EAAAA,KAAK,EAAE;AACLN,IAAAA,KAAK,EAAE,OADF;AAELC,IAAAA,KAAK,EAAE,OAFF;AAGLC,IAAAA,MAAM,EAAE,MAHH;AAILC,IAAAA,MAAM,EAAE,IAJH;AAKLC,IAAAA,SAAS,EAAE;AALN;AAtBQ,CAAjB;;AA+BA,MAAMG,UAAU,GAAGC,GAAG,IAAI;AACxB,MAAIC,MAAM,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAb;;AACA,SAAOA,MAAM,CAACA,MAAM,CAACC,MAAP,GAAgB,CAAjB,CAAN,GAA4BF,GAAnC,EAAwC;AACtCC,IAAAA,MAAM,CAACE,IAAP,CAAYF,MAAM,CAACA,MAAM,CAACC,MAAP,GAAgB,CAAjB,CAAN,GAA4BD,MAAM,CAACA,MAAM,CAACC,MAAP,GAAgB,CAAjB,CAA9C;AACD;;AACD,SAAOD,MAAP;AACD,CAND;;AAQA,MAAMG,YAAY,GAAGL,UAAU,CAAC,GAAD,CAA/B;AAEA,eAAe,MAAMM,QAAN,SAAuBrC,KAAK,CAACsC,SAA7B,CAAuC;AACpDC,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACjB,UAAMA,KAAN;;AADiB,SA0DnBC,oBA1DmB,GA0DIC,OAAO,IAAI,KAAKC,QAAL,CAAc;AAAED,MAAAA;AAAF,KAAd,CA1Df;;AAAA,SA4DnBE,qBA5DmB,GA4DKC,SAAS,IAC/B,KAAKF,QAAL,CAAc;AACZE,MAAAA,SAAS,EAAEA,SAAS,IAAI,KAAKC,KAAL,CAAWxB,QAAX,CAAoB,UAApB,EAAgCyB,KAAhC;AADZ,KAAd,CA7DiB;;AAAA,SAiEnBC,iBAjEmB,GAiEC3B,KAAK,IAAI,KAAKsB,QAAL,CAAc;AAAEtB,MAAAA;AAAF,KAAd,CAjEV;;AAAA,SAmEnB4B,kBAnEmB,GAmEEC,WAAW,IAAI;AAClC,YAAM5B,QAAQ,GAAG,KAAKwB,KAAL,CAAWxB,QAA5B;AACAA,MAAAA,QAAQ,CAAC4B,WAAD,CAAR,CAAsBC,IAAtB,GAA6B,CAAC7B,QAAQ,CAAC4B,WAAD,CAAR,CAAsBC,IAApD;AACA,WAAKR,QAAL,CAAc;AAAErB,QAAAA;AAAF,OAAd;AACD,KAvEkB;;AAAA,SAyEnB8B,mBAzEmB,GAyEG,MAAM;AAAA,0BACwB,KAAKN,KAD7B;AAAA,YAClBD,SADkB,eAClBA,SADkB;AAAA,YACPvB,QADO,eACPA,QADO;AAAA,YACG+B,OADH,eACGA,OADH;AAAA,YACYC,OADZ,eACYA,OADZ;AAE1B,YAAMC,gBAAgB,GAAGV,SAAS,CAACW,QAAV,KAAuB,GAAvB,GAA6B,IAAtD;AACA,YAAMC,IAAI,GAAG,EAAb;AAEAC,MAAAA,MAAM,CAACC,IAAP,CAAYrC,QAAZ,EAAsBsC,OAAtB,CAA8BV,WAAW,IAAI;AAC3C,cAAMW,OAAO,GAAGvC,QAAQ,CAAC4B,WAAD,CAAxB;AACA,cAAMY,MAAM,GAAG,EAAf;AACA,YAAInC,MAAM,GAAGkC,OAAO,CAAClC,MAArB;AAEAkC,QAAAA,OAAO,CAACE,OAAR,CAAgBH,OAAhB,CAAwBI,MAAM,IAAI;AAChC,cAAIA,MAAM,CAACR,QAAP,GAAkBD,gBAAgB,GAAG,CAAzC,EAA4C;AAC1C5B,YAAAA,MAAM,GAAGqC,MAAM,CAACrC,MAAP,CAAcsC,IAAd,CACP,IAAI9D,SAAJ,CAAc,CACZ0C,SAAS,CAACqB,KAAV,KAAoBrB,SAAS,CAACW,QAAV,KAAuB,CAD/B,EAEZX,SAAS,CAACsB,GAAV,KAAkBtB,SAAS,CAACW,QAAV,KAAuB,CAF7B,CAAd,CADO,CAAT;AAMD;AACF,SATD;AAWA,YAAIK,OAAO,CAACjC,SAAR,KAAsB,MAA1B,EACEkC,MAAM,CAAC3B,IAAP,CACE,oBAAC,SAAD;AACE,UAAA,GAAG,iBAAUe,WAAV,CADL;AAEE,UAAA,IAAI,YAAKA,WAAL,UAFN;AAGE,UAAA,MAAM,EAAEvB,MAHV;AAIE,UAAA,OAAO,EAAE,CAACuB,WAAD,CAJX;AAKE,UAAA,SAAS,MALX;AAME,UAAA,KAAK,EAAEhC,KANT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UADF,EADF,KAWK,IAAI2C,OAAO,CAACjC,SAAR,KAAsB,SAA1B,EAAqCkC,MAAM,CAAC3B,IAAP;AAE1C,YAAIiC,KAAK,GAAG,IAAZ;;AACA,YAAI,KAAKtB,KAAL,CAAWJ,OAAf,EAAwB;AACtB,gBAAM2B,MAAM,GACV,CAAC,CAAC,KAAKvB,KAAL,CAAWJ,OAAZ,GAAsB,CAACG,SAAS,CAACqB,KAAV,EAAxB,KACC,CAACrB,SAAS,CAACsB,GAAV,EAAD,GAAmB,CAACtB,SAAS,CAACqB,KAAV,EADrB,CADF;AAGA,gBAAMI,EAAE,GAAGC,IAAI,CAACC,KAAL,CAAWH,MAAM,GAAG1C,MAAM,CAAC8C,IAAP,EAApB,CAAX;AACA,gBAAMC,CAAC,GAAG/C,MAAM,CAACgD,MAAP,CAAc,IAAIC,IAAJ,CAAS,KAAK9B,KAAL,CAAWJ,OAApB,CAAd,EAA4C4B,EAA5C,CAAV;AACA,gBAAMO,CAAC,GAAGH,CAAC,GAAG/C,MAAM,CAAC8C,IAAP,EAAJ,GAAoB9C,MAAM,CAACmD,EAAP,CAAUJ,CAAV,EAAaK,GAAb,CAAiB7B,WAAjB,CAApB,GAAoD,IAA9D;;AACA,cAAI2B,CAAJ,EAAO;AACLT,YAAAA,KAAK,GAAGY,QAAQ,CAACH,CAAD,EAAI,EAAJ,CAAhB;AACD;AACF;;AAEDpB,QAAAA,IAAI,CAACtB,IAAL,CACE,oBAAC,QAAD;AACE,UAAA,MAAM,EAAC,IADT;AAEE,UAAA,GAAG,gBAASe,WAAT,CAFL;AAGE,UAAA,KAAK,EAAEA,WAHT;AAIE,UAAA,UAAU,EAAE;AAAE9B,YAAAA,KAAK,EAAE,MAAT;AAAiB6D,YAAAA,eAAe,EAAE;AAAlC,WAJd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAME,oBAAC,KAAD;AACE,UAAA,EAAE,YAAK/B,WAAL,UADJ;AAEE,UAAA,OAAO,EAAE,KAFX;AAGE,UAAA,GAAG,EAAEW,OAAO,CAACqB,GAHf;AAIE,UAAA,GAAG,EAAErB,OAAO,CAAC7B,GAJf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UANF,EAYE,oBAAC,MAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAS8B,MAAT,CAZF,EAaE,oBAAC,SAAD;AACE,UAAA,EAAE,YAAKZ,WAAL,eADJ;AAEE,UAAA,KAAK,EAAEkB,KAFT;AAGE,UAAA,MAAM,EAAE9C,QAAQ,CAAC4B,WAAD,CAAR,CAAsB1B,KAHhC;AAIE,UAAA,KAAK,EAAE,EAJT;AAKE,UAAA,GAAG,EAAE,CALP;AAME,UAAA,GAAG,EAAE,EANP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAbF,CADF;AAwBD,OAlED;AAoEA,aACE,oBAAC,cAAD;AACE,QAAA,SAAS,EAAE,KAAKsB,KAAL,CAAWD,SADxB;AAEE,QAAA,MAAM,EAAC,UAFT;AAGE,QAAA,QAAQ,EAAE,KAHZ;AAIE,QAAA,eAAe,EAAE,KAJnB;AAKE,QAAA,aAAa,MALf;AAME,QAAA,WAAW,EAAE,IANf;AAOE,QAAA,OAAO,EAAEQ,OAPX;AAQE,QAAA,OAAO,EAAEC,OARX;AASE,QAAA,eAAe,EAAE,KAAKR,KAAL,CAAWJ,OAT9B;AAUE,QAAA,kBAAkB,EAAE,KAAKE,qBAV3B;AAWE,QAAA,aAAa,EAAEvB,KAAK,IAAI,KAAK2B,iBAAL,CAAuB3B,KAAvB,CAX1B;AAYE,QAAA,gBAAgB,EAAE,KAAKoB,oBAZzB;AAaE,QAAA,YAAY,MAbd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAeGgB,IAfH,CADF;AAmBD,KArKkB;;AAAA,SAuKnB0B,MAvKmB,GAuKV,MACP,oBAAC,OAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACG,KAAKrC,KAAL,CAAWsC,KAAX,GACC,0CACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OACE,oBAAC,SAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAY,KAAKhC,mBAAL,EAAZ,CADF,CADF,EAIE;AACE,MAAA,KAAK,EAAE;AACLiC,QAAAA,SAAS,EAAE,mBADN;AAELJ,QAAAA,eAAe,EAAE,MAFZ;AAGL7D,QAAAA,KAAK,EAAE,KAHF;AAILkE,QAAAA,QAAQ,EAAE,UAJL;AAKLC,QAAAA,MAAM,EAAE,CALH;AAMLC,QAAAA,IAAI,EAAE,CAND;AAOLC,QAAAA,KAAK,EAAE;AAPF,OADT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAWG,KAAK3C,KAAL,CAAWJ,OAAX,aACMzC,MAAM,CAACuD,QAAP,CAAgB,CAAC,KAAKV,KAAL,CAAWJ,OAA5B,EAAqChB,MAArC,EADN,IAEG,SAbN,CAJF,EAkBS,GAlBT,CADD,GAsBC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAM,KAAN,CAvBJ,CAxKiB;;AAEjB,UAAMgE,YAAY,GAAG,IAAIvF,SAAJ,CAAc,CAAC,KAAK,EAAL,GAAU,IAAX,EAAiB,MAAM,EAAN,GAAW,IAA5B,CAAd,CAArB;AAEA,SAAK2C,KAAL,GAAa;AACXsC,MAAAA,KAAK,EAAE,KADI;AAEX9D,MAAAA,QAFW;AAGX0C,MAAAA,MAAM,EAAE,IAHG;AAIXtB,MAAAA,OAAO,EAAE,IAJE;AAKXG,MAAAA,SAAS,EAAE6C;AALA,KAAb;AAOD;;AAEDC,EAAAA,iBAAiB,GAAG;AAClBC,IAAAA,UAAU,CAAC,MAAM;AACf,YAAMtE,QAAQ,GAAG,KAAKwB,KAAL,CAAWxB,QAA5B;AACA,YAAMuE,MAAM,GAAG,EAAf;AAEAnC,MAAAA,MAAM,CAACC,IAAP,CAAYrC,QAAZ,EAAsBsC,OAAtB,CAA8BV,WAAW,IAAI;AAC3C2C,QAAAA,MAAM,CAAC3C,WAAD,CAAN,GAAsB,EAAtB;AACD,OAFD;;AAIA,WAAK,IAAIwB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG9D,IAAI,CAACkF,IAAL,CAAU5D,MAA9B,EAAsCwC,CAAC,IAAI,CAA3C,EAA8C;AAC5C,cAAMoB,IAAI,GAAGlF,IAAI,CAACkF,IAAL,CAAUpB,CAAV,IAAe,IAA5B;AACAhB,QAAAA,MAAM,CAACC,IAAP,CAAYrC,QAAZ,EAAsBsC,OAAtB,CAA8BV,WAAW,IAAI;AAC3C2C,UAAAA,MAAM,CAAC3C,WAAD,CAAN,CAAoBf,IAApB,CAAyB,CAAC2D,IAAD,EAAOlF,IAAI,CAACsC,WAAD,CAAJ,CAAkBwB,CAAlB,CAAP,CAAzB;AACD,SAFD;AAGD;;AAEDhB,MAAAA,MAAM,CAACC,IAAP,CAAYrC,QAAZ,EAAsBsC,OAAtB,CAA8BV,WAAW,IAAI;AAC3C,cAAMW,OAAO,GAAGvC,QAAQ,CAAC4B,WAAD,CAAxB;AACA,cAAMvB,MAAM,GAAG,IAAIzB,UAAJ,CAAe;AAC5B6F,UAAAA,IAAI,EAAElC,OAAO,CAACkC,IADc;AAE5BC,UAAAA,OAAO,EAAE,CAAC,MAAD,EAAS9C,WAAT,CAFmB;AAG5B2C,UAAAA,MAAM,EAAEA,MAAM,CAAC3C,WAAD;AAHc,SAAf,CAAf;AAMAW,QAAAA,OAAO,CAAClC,MAAR,GAAiBA,MAAjB;AAEAkC,QAAAA,OAAO,CAACE,OAAR,GAAkB3B,YAAY,CAAC6D,GAAb,CAAiBC,WAAW,KAAK;AACjD1C,UAAAA,QAAQ,EAAE0C,WADuC;AAEjDvE,UAAAA,MAAM,EAAEA,MAAM,CAACwE,iBAAP,CAAyB;AAC/BC,YAAAA,UAAU,EAAEF,WAAW,GAAG,GADK;AAE/BG,YAAAA,WAAW,EAAE;AAAE,eAACnD,WAAD,GAAe;AAAE,iBAACA,WAAD,GAAe9C,GAAG;AAApB;AAAjB;AAFkB,WAAzB;AAFyC,SAAL,CAA5B,CAAlB;AAQAyD,QAAAA,OAAO,CAACzD,GAAR,GAAc4E,QAAQ,CAACrD,MAAM,CAACvB,GAAP,CAAW8C,WAAX,CAAD,EAA0B,EAA1B,CAAtB;AACAW,QAAAA,OAAO,CAACqB,GAAR,GAAcF,QAAQ,CAACrD,MAAM,CAACuD,GAAP,CAAWhC,WAAX,CAAD,EAA0B,EAA1B,CAAtB;AACAW,QAAAA,OAAO,CAAC7B,GAAR,GAAcgD,QAAQ,CAACrD,MAAM,CAACK,GAAP,CAAWkB,WAAX,CAAD,EAA0B,EAA1B,CAAtB;AACD,OArBD;AAuBA,YAAMI,OAAO,GAAGhC,QAAQ,CAACC,QAAT,CAAkBI,MAAlB,CAAyBoB,KAAzB,GAAiCmB,KAAjC,EAAhB;AACA,YAAMb,OAAO,GAAG/B,QAAQ,CAACC,QAAT,CAAkBI,MAAlB,CAAyBoB,KAAzB,GAAiCoB,GAAjC,EAAhB;AACA,WAAKxB,QAAL,CAAc;AAAEyC,QAAAA,KAAK,EAAE,IAAT;AAAe9D,QAAAA,QAAf;AAAyBgC,QAAAA,OAAzB;AAAkCD,QAAAA;AAAlC,OAAd;AACD,KAzCS,EAyCP,CAzCO,CAAV;AA0CD;;AAzDmD","sourcesContent":["import React from \"react\";\r\nimport \"moment-duration-format\";\r\nimport moment from \"moment\";\r\nimport { TimeSeries, TimeRange, avg } from \"pondjs\";\r\nimport ChartContainer from \"./ChartContainer\";\r\nimport ChartRow from \"./ChartRow\";\r\nimport Charts from \"./Charts\";\r\nimport YAxis from \"./YAxis\";\r\nimport LineChart from \"./LineChart\";\r\nimport Resizable from \"./Resizable\";\r\nimport ValueAxis from \"./ValueAxis\";\r\nimport data from \"./bike.json\";\r\nimport styled from \"styled-components\";\r\nimport styler from \"./utils/styler\";\r\nimport { islandCss } from \"./Dashboard\";\r\n\r\nconst Wrapper = styled.div`\r\n  overflow: hidden;\r\n  width: 100%;\r\n  background-color: #222;\r\n  position: relative;\r\n  margin: 0.25rem;\r\n  box-shadow: 0.1rem 0.1rem 0.05rem rgba(0, 0, 0, 0.3);\r\n  border-radius: 0.2rem;\r\n`;\r\n\r\nconst style = styler([\r\n  { key: \"altitude\", color: \"magenta\", width: 2 },\r\n  { key: \"cadence\", color: \"yellow\", width: 2 },\r\n  { key: \"power\", color: \"lime\", width: 2 },\r\n  { key: \"moving\", color: \"red\", width: 2 }\r\n]);\r\n\r\nconst channels = {\r\n  altitude: {\r\n    units: \"feet\",\r\n    label: \"Altitude\",\r\n    format: \"d\",\r\n    series: null,\r\n    chartType: \"line\"\r\n  },\r\n  cadence: {\r\n    units: \"rpm\",\r\n    label: \"Cadence\",\r\n    format: \"d\",\r\n    series: null,\r\n    chartType: \"line\"\r\n  },\r\n  // moving: {\r\n  //   units: \"watts\",\r\n  //   label: \"Moving\",\r\n  //   format: \",.1f\",\r\n  //   series: null,\r\n  //   chartType: \"boolean\"\r\n  // },\r\n  power: {\r\n    units: \"watts\",\r\n    label: \"Power\",\r\n    format: \",.1f\",\r\n    series: null,\r\n    chartType: \"line\"\r\n  }\r\n};\r\n\r\nconst fibbonacci = max => {\r\n  var result = [1, 2];\r\n  while (result[result.length - 1] < max) {\r\n    result.push(result[result.length - 1] + result[result.length - 2]);\r\n  }\r\n  return result;\r\n};\r\n\r\nconst rollupLevels = fibbonacci(200);\r\n\r\nexport default class Timeline extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    const initialRange = new TimeRange([75 * 60 * 1000, 125 * 60 * 1000]);\r\n\r\n    this.state = {\r\n      ready: false,\r\n      channels,\r\n      rollup: \"1m\",\r\n      tracker: null,\r\n      timerange: initialRange\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    setTimeout(() => {\r\n      const channels = this.state.channels;\r\n      const points = {};\r\n\r\n      Object.keys(channels).forEach(channelName => {\r\n        points[channelName] = [];\r\n      });\r\n\r\n      for (let i = 1; i < data.time.length; i += 1) {\r\n        const time = data.time[i] * 1000;\r\n        Object.keys(channels).forEach(channelName => {\r\n          points[channelName].push([time, data[channelName][i]]);\r\n        });\r\n      }\r\n\r\n      Object.keys(channels).forEach(channelName => {\r\n        const channel = channels[channelName];\r\n        const series = new TimeSeries({\r\n          name: channel.name,\r\n          columns: [\"time\", channelName],\r\n          points: points[channelName]\r\n        });\r\n\r\n        channel.series = series;\r\n\r\n        channel.rollups = rollupLevels.map(rollupLevel => ({\r\n          duration: rollupLevel,\r\n          series: series.fixedWindowRollup({\r\n            windowSize: rollupLevel + \"s\",\r\n            aggregation: { [channelName]: { [channelName]: avg() } }\r\n          })\r\n        }));\r\n\r\n        channel.avg = parseInt(series.avg(channelName), 10);\r\n        channel.min = parseInt(series.min(channelName), 10);\r\n        channel.max = parseInt(series.max(channelName), 10);\r\n      });\r\n\r\n      const minTime = channels.altitude.series.range().begin();\r\n      const maxTime = channels.altitude.series.range().end();\r\n      this.setState({ ready: true, channels, minTime, maxTime });\r\n    }, 0);\r\n  }\r\n\r\n  handleTrackerChanged = tracker => this.setState({ tracker });\r\n\r\n  handleTimeRangeChange = timerange =>\r\n    this.setState({\r\n      timerange: timerange || this.state.channels[\"altitude\"].range()\r\n    });\r\n\r\n  handleChartResize = width => this.setState({ width });\r\n\r\n  handleActiveChange = channelName => {\r\n    const channels = this.state.channels;\r\n    channels[channelName].show = !channels[channelName].show;\r\n    this.setState({ channels });\r\n  };\r\n\r\n  renderChannelsChart = () => {\r\n    const { timerange, channels, maxTime, minTime } = this.state;\r\n    const durationPerPixel = timerange.duration() / 800 / 1000;\r\n    const rows = [];\r\n\r\n    Object.keys(channels).forEach(channelName => {\r\n      const channel = channels[channelName];\r\n      const charts = [];\r\n      let series = channel.series;\r\n\r\n      channel.rollups.forEach(rollup => {\r\n        if (rollup.duration < durationPerPixel * 2) {\r\n          series = rollup.series.crop(\r\n            new TimeRange([\r\n              timerange.begin() - timerange.duration() / 2,\r\n              timerange.end() + timerange.duration() / 2\r\n            ])\r\n          );\r\n        }\r\n      });\r\n\r\n      if (channel.chartType === \"line\")\r\n        charts.push(\r\n          <LineChart\r\n            key={`line-${channelName}`}\r\n            axis={`${channelName}_axis`}\r\n            series={series}\r\n            columns={[channelName]}\r\n            breakLine\r\n            style={style}\r\n          />\r\n        );\r\n      else if (channel.chartType === \"boolean\") charts.push();\r\n\r\n      let value = \"--\";\r\n      if (this.state.tracker) {\r\n        const approx =\r\n          (+this.state.tracker - +timerange.begin()) /\r\n          (+timerange.end() - +timerange.begin());\r\n        const ii = Math.floor(approx * series.size());\r\n        const i = series.bisect(new Date(this.state.tracker), ii);\r\n        const v = i < series.size() ? series.at(i).get(channelName) : null;\r\n        if (v) {\r\n          value = parseInt(v, 10);\r\n        }\r\n      }\r\n\r\n      rows.push(\r\n        <ChartRow\r\n          height=\"80\"\r\n          key={`row-${channelName}`}\r\n          title={channelName}\r\n          titleStyle={{ color: \"#fff\", backgroundColor: \"#222\" }}\r\n        >\r\n          <YAxis\r\n            id={`${channelName}_axis`}\r\n            visible={false}\r\n            min={channel.min}\r\n            max={channel.max}\r\n          />\r\n          <Charts>{charts}</Charts>\r\n          <ValueAxis\r\n            id={`${channelName}_valueaxis`}\r\n            value={value}\r\n            detail={channels[channelName].units}\r\n            width={60}\r\n            min={0}\r\n            max={35}\r\n          />\r\n        </ChartRow>\r\n      );\r\n    });\r\n\r\n    return (\r\n      <ChartContainer\r\n        timeRange={this.state.timerange}\r\n        format=\"relative\"\r\n        showGrid={false}\r\n        trackerShowTime={false}\r\n        enablePanZoom\r\n        minDuration={1000}\r\n        maxTime={maxTime}\r\n        minTime={minTime}\r\n        trackerPosition={this.state.tracker}\r\n        onTimeRangeChanged={this.handleTimeRangeChange}\r\n        onChartResize={width => this.handleChartResize(width)}\r\n        onTrackerChanged={this.handleTrackerChanged}\r\n        hideTimeAxis\r\n      >\r\n        {rows}\r\n      </ChartContainer>\r\n    );\r\n  };\r\n\r\n  render = () => (\r\n    <Wrapper>\r\n      {this.state.ready ? (\r\n        <>\r\n          <div>\r\n            <Resizable>{this.renderChannelsChart()}</Resizable>\r\n          </div>\r\n          <div\r\n            style={{\r\n              borderTop: \"0.2rem solid #aaa\",\r\n              backgroundColor: \"#ccc\",\r\n              color: \"fff\",\r\n              position: \"absolute\",\r\n              bottom: 0,\r\n              left: 0,\r\n              right: 0\r\n            }}\r\n          >\r\n            {this.state.tracker\r\n              ? `${moment.duration(+this.state.tracker).format()}`\r\n              : \"-:--:--\"}\r\n          </div>{\" \"}\r\n        </>\r\n      ) : (\r\n        <div>{\"...\"}</div>\r\n      )}\r\n    </Wrapper>\r\n  );\r\n}\r\n"]},"metadata":{},"sourceType":"module"}